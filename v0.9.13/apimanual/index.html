<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · MathOptInterface</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MathOptInterface</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Purpose-1"><span>Purpose</span></a></li><li><a class="tocitem" href="#Standard-form-problem-1"><span>Standard form problem</span></a></li><li><a class="tocitem" href="#The-ModelLike-and-AbstractOptimizer-APIs-1"><span>The <code>ModelLike</code> and <code>AbstractOptimizer</code> APIs</span></a></li><li><a class="tocitem" href="#Adding-variables-1"><span>Adding variables</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li><li><a class="tocitem" href="#Sets-and-Constraints-1"><span>Sets and Constraints</span></a></li><li><a class="tocitem" href="#Solving-and-retrieving-the-results-1"><span>Solving and retrieving the results</span></a></li><li><a class="tocitem" href="#A-complete-example:-solving-a-knapsack-problem-1"><span>A complete example: solving a knapsack problem</span></a></li><li><a class="tocitem" href="#Problem-modification-1"><span>Problem modification</span></a></li><li><a class="tocitem" href="#File-formats-1"><span>File formats</span></a></li><li><a class="tocitem" href="#Advanced-1"><span>Advanced</span></a></li><li><a class="tocitem" href="#Implementing-a-solver-interface-1"><span>Implementing a solver interface</span></a></li></ul></li><li><a class="tocitem" href="../apireference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/master/docs/src/apimanual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual-1"><a class="docs-heading-anchor" href="#Manual-1">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-1" title="Permalink"></a></h1><h2 id="Purpose-1"><a class="docs-heading-anchor" href="#Purpose-1">Purpose</a><a class="docs-heading-anchor-permalink" href="#Purpose-1" title="Permalink"></a></h2><p>Each mathematical optimization solver API has its own concepts and data structures for representing optimization models and obtaining results. However, it is often desirable to represent an instance of an optimization problem at a higher level so that it is easy to try using different solvers. MathOptInterface (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>.</p><p>MOI has been designed to replace <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a>, which has been used by modeling packages such as <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> and <a href="https://github.com/JuliaOpt/Convex.jl">Convex.jl</a>. This second-generation abstraction layer addresses a number of limitations of MathProgBase. MOI is designed to:</p><ul><li>Be simple and extensible, unifying linear, quadratic, and conic optimization, and seamlessly facilitate extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise linear functions)</li><li>Be fast by allowing access to a solver&#39;s in-memory representation of a problem without writing intermediate files (when possible) and by using multiple dispatch and avoiding requiring containers of nonconcrete types</li><li>Allow a solver to return multiple results (e.g., a pool of solutions)</li><li>Allow a solver to return extra arbitrary information via attributes (e.g., variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)</li><li>Provide a greatly expanded set of status codes explaining what happened during the optimization procedure</li><li>Enable a solver to more precisely specify which problem classes it supports</li><li>Enable both primal and dual warm starts</li><li>Enable adding and removing both variables and constraints by indices that are not required to be consecutive</li><li>Enable any modification that the solver supports to an existing model</li><li>Avoid requiring the solver wrapper to store an additional copy of the problem data</li></ul><p>This manual introduces the concepts needed to understand MOI and give a high-level picture of how all of the pieces fit together. The primary focus is on MOI from the perspective of a user of the interface. At the end of the manual we have a section on <a href="#Implementing-a-solver-interface-1">Implementing a solver interface</a>. The <a href="../apireference/#API-Reference-1">API Reference</a> page lists the complete API.</p><p>MOI does not export functions, but for brevity we often omit qualifying names with the MOI module. Best practice is to have</p><pre><code class="language-julia">using MathOptInterface
const MOI = MathOptInterface</code></pre><p>and prefix all MOI methods with <code>MOI.</code> in user code. If a name is also available in base Julia, we always explicitly use the module prefix, for example, with <code>MOI.get</code>.</p><h2 id="Standard-form-problem-1"><a class="docs-heading-anchor" href="#Standard-form-problem-1">Standard form problem</a><a class="docs-heading-anchor-permalink" href="#Standard-form-problem-1" title="Permalink"></a></h2><p>The standard form problem is:</p><div>\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>where:</p><ul><li>the functions <span>$f_0, f_1, \ldots, f_m$</span> are specified by <a href="../apireference/#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> objects</li><li>the sets <span>$\mathcal{S}_1, \ldots, \mathcal{S}_m$</span> are specified by <a href="../apireference/#MathOptInterface.AbstractSet"><code>AbstractSet</code></a> objects</li></ul><p>The current function types are:</p><ul><li><strong><a href="../apireference/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a></strong>: <span>$x_j$</span>, i.e., projection onto a single coordinate defined by a variable index <span>$j$</span></li><li><strong><a href="../apireference/#MathOptInterface.VectorOfVariables"><code>VectorOfVariables</code></a></strong>: projection onto multiple coordinates (i.e., extracting a subvector)</li><li><strong><a href="../apireference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a></strong>: <span>$a^T x + b$</span>, where <span>$a$</span> is a vector and <span>$b$</span> scalar</li><li><strong><a href="../apireference/#MathOptInterface.VectorAffineFunction"><code>VectorAffineFunction</code></a></strong>: <span>$A x + b$</span>, where <span>$A$</span> is a matrix and <span>$b$</span> is a vector</li><li><strong><a href="../apireference/#MathOptInterface.ScalarQuadraticFunction"><code>ScalarQuadraticFunction</code></a></strong>: <span>$\frac{1}{2} x^T Q x + a^T x + b$</span>, where <span>$Q$</span> is a symmetric matrix, <span>$a$</span> is a vector, and <span>$b$</span> is a constant</li><li><strong><a href="../apireference/#MathOptInterface.VectorQuadraticFunction"><code>VectorQuadraticFunction</code></a></strong>: a vector of scalar-valued quadratic functions</li></ul><p>Extensions for nonlinear programming are present but not yet well documented.</p><p>MOI defines some commonly used sets, but the interface is extensible to other sets recognized by the solver.</p><ul><li><strong><a href="../apireference/#MathOptInterface.LessThan"><code>LessThan(upper)</code></a></strong>: <span>$\{ x \in \mathbb{R} : x \le \mbox{upper} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.GreaterThan"><code>GreaterThan(lower)</code></a></strong>: <span>$\{ x \in \mathbb{R} : x \ge \mbox{lower} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.GreaterThan"><code>EqualTo(value)</code></a></strong>: <span>$\{ x \in \mathbb{R} : x = \mbox{value} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Interval"><code>Interval(lower, upper)</code></a></strong>: <span>$\{ x \in \mathbb{R} : x \in [\mbox{lower},\mbox{upper}] \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Reals"><code>Reals(dimension)</code></a></strong>: <span>$\mathbb{R}^\mbox{dimension}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Zeros"><code>Zeros(dimension)</code></a></strong>: <span>$0^\mbox{dimension}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Nonnegatives"><code>Nonnegatives(dimension)</code></a></strong>: <span>$\{ x \in \mathbb{R}^\mbox{dimension} : x \ge 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Nonpositives"><code>Nonpositives(dimension)</code></a></strong>: <span>$\{ x \in \mathbb{R}^\mbox{dimension} : x \le 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.NormInfinityCone"><code>NormInfinityCone(dimension)</code></a></strong>: <span>$\{ (t,x) \in \mathbb{R}^\mbox{dimension} : t \ge \lVert x \rVert_\infty = \max_i \lvert x_i \rvert \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.NormOneCone"><code>NormOneCone(dimension)</code></a></strong>: <span>$\{ (t,x) \in \mathbb{R}^\mbox{dimension} : t \ge \lVert x \rVert_\infty_1 = \sum_i \lvert x_i \rvert \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.SecondOrderCone"><code>SecondOrderCone(dimension)</code></a></strong>: <span>$\{ (t,x) \in \mathbb{R}^\mbox{dimension} : t \ge ||x||_2 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.RotatedSecondOrderCone"><code>RotatedSecondOrderCone(dimension)</code></a></strong>: <span>$\{ (t,u,x) \in \mathbb{R}^\mbox{dimension} : 2tu \ge ||x||_2^2, t,u \ge 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.GeometricMeanCone"><code>GeometricMeanCone(dimension)</code></a></strong>: <span>$\{ (t,x) \in \mathbb{R}^{n+1} : x \ge 0, t \le \sqrt[n]{x_1 x_2 \cdots x_n} \}$</span> where <span>$n$</span> is <span>$dimension - 1$</span></li><li><strong><a href="../apireference/#MathOptInterface.ExponentialCone"><code>ExponentialCone()</code></a></strong>: <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.DualExponentialCone"><code>DualExponentialCone()</code></a></strong>: <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le exp(1) w, u &lt; 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.PowerCone"><code>PowerCone(exponent)</code></a></strong>: <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^\mbox{exponent} y^{1-\mbox{exponent}} \ge |z|, x,y \ge 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.DualPowerCone"><code>DualPowerCone(exponent)</code></a></strong>: <span>$\{ (u,v,w) \in \mathbb{R}^3 : \frac{u}{\mbox{exponent}}^\mbox{exponent} \frac{v}{1-\mbox{exponent}}^{1-\mbox{exponent}} \ge |w|, u,v \ge 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.RelativeEntropyCone"><code>RelativeEntropyCone(dimension)</code></a></strong>: <span>$\{ (u, v, w) \in \mathbb{R}^\mbox{dimension} : u \ge \sum_i w_i \log (\frac{w_i}{v_i}), v_i \ge 0, w_i \ge 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.NormSpectralCone"><code>NormSpectralCone(row_dim, column_dim)</code></a></strong>: <span>$\{ (t, X) \in \mathbb{R}^{1 + \mbox{row_dim} \times \mbox{column_dim} : t \ge \sigma_1(X), X \mbox{is a matrix with row_dim rows and column_dim columns} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.NormNuclearCone"><code>NormNuclearCone(row_dim, column_dim)</code></a></strong>: <span>$\{ (t, X) \in \mathbb{R}^{1 + \mbox{row_dim} \times \mbox{column_dim} : t \ge \sum_i \sigma_i(X), X \mbox{is a matrix with row_dim rows and column_dim columns} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>PositiveSemidefiniteConeTriangle(dimension)</code></a></strong>: <span>$\{ X \in \mathbb{R}^{\mbox{dimension}(\mbox{dimension}+1)/2} : X \mbox{is the upper triangle of a PSD matrix} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.PositiveSemidefiniteConeSquare"><code>PositiveSemidefiniteConeSquare(dimension)</code></a></strong>: <span>$\{ X \in \mathbb{R}^{\mbox{dimension}^2} : X \mbox{is a PSD matrix} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.LogDetConeTriangle"><code>LogDetConeTriangle(dimension)</code></a></strong>: <span>$\{ (t,u,X) \in \mathbb{R}^{2+\mbox{dimension}(1+\mbox{dimension})/2} : t \le u\log(\det(X/u)), X \mbox{is the upper triangle of a PSD matrix}, u &gt; 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.LogDetConeSquare"><code>LogDetConeSquare(dimension)</code></a></strong>: <span>$\{ (t,u,X) \in \mathbb{R}^{2+\mbox{dimension}^2} : t \le u \log(\det(X/u)), X \mbox{is a PSD matrix}, u &gt; 0 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.RootDetConeTriangle"><code>RootDetConeTriangle(dimension)</code></a></strong>: <span>$\{ (t,X) \in \mathbb{R}^{1+\mbox{dimension}(1+\mbox{dimension})/2} : t \le det(X)^{1/\mbox{dimension}}, X \mbox{is the upper triangle of a PSD matrix} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.RootDetConeSquare"><code>RootDetConeSquare(dimension)</code></a></strong>: <span>$\{ (t,X) \in \mathbb{R}^{1+\mbox{dimension}^2} : t \le \det(X)^{1/\mbox{dimension}}, X \mbox{is a PSD matrix} \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Integer"><code>Integer()</code></a></strong>: <span>$\mathbb{Z}$</span></li><li><strong><a href="../apireference/#MathOptInterface.ZeroOne"><code>ZeroOne()</code></a></strong>: <span>$\{ 0, 1 \}$</span></li><li><strong><a href="../apireference/#MathOptInterface.Semicontinuous"><code>Semicontinuous(lower,upper)</code></a></strong>: <span>$\{ 0\} \cup [lower,upper]$</span></li><li><strong><a href="../apireference/#MathOptInterface.Semiinteger"><code>Semiinteger(lower,upper)</code></a></strong>: <span>$\{ 0\} \cup \{lower,lower+1,\ldots,upper-1,upper\}$</span></li></ul><h2 id="The-ModelLike-and-AbstractOptimizer-APIs-1"><a class="docs-heading-anchor" href="#The-ModelLike-and-AbstractOptimizer-APIs-1">The <code>ModelLike</code> and <code>AbstractOptimizer</code> APIs</a><a class="docs-heading-anchor-permalink" href="#The-ModelLike-and-AbstractOptimizer-APIs-1" title="Permalink"></a></h2><p>The most significant part of MOI is the definition of the <strong>model API</strong> that is used to specify an instance of an optimization problem (e.g., by adding variables and constraints). Objects that implement the model API should inherit from the <a href="../apireference/#MathOptInterface.ModelLike"><code>ModelLike</code></a> abstract type.</p><p>Notably missing from the model API is the method to solve an optimization problem. <code>ModelLike</code> objects may store an instance (e.g., in memory or backed by a file format) without being linked to a particular solver. In addition to the model API, MOI defines <a href="../apireference/#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a>. <em>Optimizers</em> (or solvers) implement the model API (inheriting from <code>ModelLike</code>) and additionally provide methods to solve the model.</p><p>Through the rest of the manual, <code>model</code> is used as a generic <code>ModelLike</code>, and <code>optimizer</code> is used as a generic <code>AbstractOptimizer</code>.</p><p>Models are constructed by</p><ul><li>adding variables using <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a> (or <a href="../apireference/#MathOptInterface.add_variables"><code>add_variables</code></a>), see <a href="#Adding-variables-1">Adding variables</a>;</li><li>setting an objective sense and function using <a href="../apireference/#MathOptInterface.set"><code>set</code></a>, see <a href="#Setting-an-objective-1">Setting an objective</a>;</li><li>and adding constraints using <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> (or <a href="../apireference/#MathOptInterface.add_constraints"><code>add_constraints</code></a>), see <a href="#Sets-and-Constraints-1">Sets and Constraints</a>.</li></ul><p>The way the problem is solved by the optimimizer is controlled by <a href="../apireference/#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>s, see <a href="#Solver-specific-attributes-1">Solver-specific attributes</a>.</p><h2 id="Adding-variables-1"><a class="docs-heading-anchor" href="#Adding-variables-1">Adding variables</a><a class="docs-heading-anchor-permalink" href="#Adding-variables-1" title="Permalink"></a></h2><p>All variables in MOI are scalar variables. New scalar variables are created with <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a> or <a href="../apireference/#MathOptInterface.add_variables"><code>add_variables</code></a>, which return a <a href="../apireference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> or <code>Vector{VariableIndex}</code> respectively. <code>VariableIndex</code> objects are type-safe wrappers around integers that refer to a variable in a particular model.</p><p>One uses <code>VariableIndex</code> objects to set and get variable attributes. For example, the <a href="../apireference/#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> attribute is used to provide an initial starting point for a variable or collection of variables:</p><pre><code class="language-julia">v = add_variable(model)
set(model, VariablePrimalStart(), v, 10.5)
v2 = add_variables(model, 3)
set(model, VariablePrimalStart(), v2, [1.3,6.8,-4.6])</code></pre><p>A variable can be deleted from a model with <a href="../apireference/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}"><code>delete(::ModelLike, ::VariableIndex)</code></a>. Not all models support deleting variables; an <a href="../apireference/#MathOptInterface.DeleteNotAllowed"><code>DeleteNotAllowed</code></a> error is thrown if this is not supported.</p><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><p>MOI defines six functions as listed in the definition of the <a href="#Standard-form-problem-1">Standard form problem</a>. The simplest function is <a href="../apireference/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> defined as:</p><pre><code class="language-julia">struct SingleVariable &lt;: AbstractFunction
    variable::VariableIndex
end</code></pre><p>If <code>v</code> is a <code>VariableIndex</code> object, then <code>SingleVariable(v)</code> is simply the scalar-valued function from the complete set of variables in a model that returns the value of variable <code>v</code>. One may also call this function a coordinate projection, which is more useful for defining constraints than as an objective function.</p><p>A more interesting function is <a href="../apireference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>, defined as</p><pre><code class="language-julia">struct ScalarAffineFunction{T} &lt;: AbstractScalarFunction
    terms::Vector{ScalarAffineTerm{T}}
    constant::T
end</code></pre><p>The <a href="../apireference/#MathOptInterface.ScalarAffineTerm"><code>ScalarAffineTerm</code></a> struct defines a variable-coefficient pair:</p><pre><code class="language-julia">struct ScalarAffineTerm{T}
    coefficient::T
    variable_index::VariableIndex
end</code></pre><p>If <code>x</code> is a vector of <code>VariableIndex</code> objects, then <code>ScalarAffineFunction(ScalarAffineTerm.([5.0,-2.3],[x[1],x[2]]),1.0)</code> represents the function <span>$5x_1 - 2.3x_2 + 1$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ScalarAffineTerm.([5.0,-2.3],[x[1],x[2]])</code> is a shortcut for <code>[ScalarAffineTerm(5.0, x[1]), ScalarAffineTerm(-2.3, x[2])]</code>. This is Julia&#39;s broadcast syntax and is used quite often.</p></div></div><h3 id="Setting-an-objective-1"><a class="docs-heading-anchor" href="#Setting-an-objective-1">Setting an objective</a><a class="docs-heading-anchor-permalink" href="#Setting-an-objective-1" title="Permalink"></a></h3><p>Objective functions are assigned to a model by setting the <a href="../apireference/#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute. The <a href="../apireference/#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a> attribute is used for setting the optimization sense. For example,</p><pre><code class="language-julia">x = add_variables(model, 2)
set(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(),
            ScalarAffineFunction(ScalarAffineTerm.([5.0,-2.3],[x[1],x[2]]),1.0))
set(model, ObjectiveSense(), MIN_SENSE)</code></pre><p>sets the objective to the function just discussed in the minimization sense.</p><p>See <a href="../apireference/#Functions-and-function-modifications-1">Functions and function modifications</a> for the complete list of functions.</p><h2 id="Sets-and-Constraints-1"><a class="docs-heading-anchor" href="#Sets-and-Constraints-1">Sets and Constraints</a><a class="docs-heading-anchor-permalink" href="#Sets-and-Constraints-1" title="Permalink"></a></h2><p>All constraints are specified with <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> by restricting the output of some function to a set. The interface allows an arbitrary combination of functions and sets, but of course solvers may decide to support only a small number of combinations.</p><p>For example, linear programming solvers should support, at least, combinations of affine functions with the <a href="../apireference/#MathOptInterface.LessThan"><code>LessThan</code></a> and <a href="../apireference/#MathOptInterface.GreaterThan"><code>GreaterThan</code></a> sets. These are simply linear constraints. <code>SingleVariable</code> functions combined with these same sets are used to specify upper and lower bounds on variables.</p><p>The code example below encodes the linear optimization problem:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^2} &amp; 3x_1 + 2x_2 &amp;
\\
&amp; \;\;\text{s.t.} &amp; x_1 + x_2 &amp;\le 5
\\
&amp;&amp; x_1 &amp; \ge 0
\\
&amp;&amp;x_2 &amp; \ge -1
\end{align}\]</div><pre><code class="language-julia">x = add_variables(model, 2)
set(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(),
            ScalarAffineFunction(ScalarAffineTerm.([3.0, 2.0], x), 0.0))
set(model, ObjectiveSense(), MAX_SENSE)
add_constraint(model, ScalarAffineFunction(ScalarAffineTerm.(1.0, x), 0.0),
                      LessThan(5.0))
add_constraint(model, SingleVariable(x[1]), GreaterThan(0.0))
add_constraint(model, SingleVariable(x[2]), GreaterThan(-1.0))</code></pre><p>Besides scalar-valued functions in scalar-valued sets it possible to use vector-valued functions and sets.</p><p>The code example below encodes the convex optimization problem:</p><div>\[\begin{align}
&amp; \max_{x,y,z \in \mathbb{R}} &amp; y + z &amp;
\\
&amp; \;\;\text{s.t.} &amp; 3x &amp;= 2
\\
&amp;&amp; x &amp; \ge ||(y,z)||_2
\end{align}\]</div><pre><code class="language-julia">x,y,z = add_variables(model, 3)
set(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(),
            ScalarAffineFunction(ScalarAffineTerm.(1.0, [y,z]), 0.0))
set(model, ObjectiveSense(), MAX_SENSE)
vector_terms = [VectorAffineTerm(1, ScalarAffineTerm(3.0, x))]
add_constraint(model, VectorAffineFunction(vector_terms,[-2.0]), Zeros(1))
add_constraint(model, VectorOfVariables([x,y,z]), SecondOrderCone(3))</code></pre><p>[Describe <code>ConstraintIndex</code> objects.]</p><h3 id="Constraints-by-function-set-pairs-1"><a class="docs-heading-anchor" href="#Constraints-by-function-set-pairs-1">Constraints by function-set pairs</a><a class="docs-heading-anchor-permalink" href="#Constraints-by-function-set-pairs-1" title="Permalink"></a></h3><p>Below is a list of common constraint types and how they are represented as function-set pairs in MOI. In the notation below, <span>$x$</span> is a vector of decision variables, <span>$x_i$</span> is a scalar decision variable, <span>$\alpha, \beta$</span> are scalar constants, <span>$a, b$</span> are constant vectors, <code>A</code> is a constant matrix and <span>$\mathbb{R}_+$</span> (resp. <span>$\mathbb{R}_-$</span>) is the set of nonnegative (resp. nonpositive) real numbers.</p><h4 id="Linear-constraints-1"><a class="docs-heading-anchor" href="#Linear-constraints-1">Linear constraints</a><a class="docs-heading-anchor-permalink" href="#Linear-constraints-1" title="Permalink"></a></h4><table><tr><th style="text-align: right">Mathematical Constraint</th><th style="text-align: right">MOI Function</th><th style="text-align: right">MOI Set</th></tr><tr><td style="text-align: right"><span>$a^Tx \le \beta$</span></td><td style="text-align: right"><code>ScalarAffineFunction</code></td><td style="text-align: right"><code>LessThan</code></td></tr><tr><td style="text-align: right"><span>$a^Tx \ge \alpha$</span></td><td style="text-align: right"><code>ScalarAffineFunction</code></td><td style="text-align: right"><code>GreaterThan</code></td></tr><tr><td style="text-align: right"><span>$a^Tx = \beta$</span></td><td style="text-align: right"><code>ScalarAffineFunction</code></td><td style="text-align: right"><code>EqualTo</code></td></tr><tr><td style="text-align: right"><span>$\alpha \le a^Tx \le \beta$</span></td><td style="text-align: right"><code>ScalarAffineFunction</code></td><td style="text-align: right"><code>Interval</code></td></tr><tr><td style="text-align: right"><span>$x_i \le \beta$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>LessThan</code></td></tr><tr><td style="text-align: right"><span>$x_i \ge \alpha$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>GreaterThan</code></td></tr><tr><td style="text-align: right"><span>$x_i = \beta$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>EqualTo</code></td></tr><tr><td style="text-align: right"><span>$\alpha \le x_i \le \beta$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>Interval</code></td></tr><tr><td style="text-align: right"><span>$Ax + b \in \mathbb{R}_+^n$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>Nonnegatives</code></td></tr><tr><td style="text-align: right"><span>$Ax + b \in \mathbb{R}_-^n$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>Nonpositives</code></td></tr><tr><td style="text-align: right"><span>$Ax + b = 0$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>Zeros</code></td></tr></table><p>By convention, solvers are not expected to support nonzero constant terms in the <code>ScalarAffineFunction</code>s the first four rows above, because they are redundant with the parameters of the sets. For example, <span>$2x + 1 \le 2$</span> should be encoded as <span>$2x \le 1$</span>.</p><p>Constraints with <code>SingleVariable</code> in <code>LessThan</code>, <code>GreaterThan</code>, <code>EqualTo</code>, or <code>Interval</code> sets have a natural interpretation as variable bounds. As such, it is typically not natural to impose multiple lower or upper bounds on the same variable, and the solver interfaces should throw respectively <a href="../apireference/#MathOptInterface.LowerBoundAlreadySet"><code>LowerBoundAlreadySet</code></a> or <a href="../apireference/#MathOptInterface.UpperBoundAlreadySet"><code>UpperBoundAlreadySet</code></a>. Moreover, adding two <code>SingleVariable</code> constraints on the same variable with the same set is impossible because they share the same index as it is the index of the variable, see <a href="../apireference/#MathOptInterface.ConstraintIndex"><code>ConstraintIndex</code></a>. It is natural, however, to impose upper and lower bounds separately as two different constraints on a single variable. The difference between imposing bounds by using a single <code>Interval</code> constraint and by using separate <code>LessThan</code> and <code>GreaterThan</code> constraints is that the latter will allow the solver to return separate dual multipliers for the two bounds, while the former will allow the solver to return only a single dual for the interval constraint.</p><h4 id="Conic-constraints-1"><a class="docs-heading-anchor" href="#Conic-constraints-1">Conic constraints</a><a class="docs-heading-anchor-permalink" href="#Conic-constraints-1" title="Permalink"></a></h4><table><tr><th style="text-align: right">Mathematical Constraint</th><th style="text-align: right">MOI Function</th><th style="text-align: right">MOI Set</th></tr><tr><td style="text-align: right"><span>$\lVert Ax + b\rVert_2 \le c^Tx + d$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: right"><span>$y \ge \lVert x \rVert_2$</span></td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: right"><span>$2yz \ge \lVert x \rVert_2^2, y,z \ge 0$</span></td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: right"><span>$(a_1^Tx + b_1,a_2^Tx + b_2,a_3^Tx + b_3) \in \mathcal{E}$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>ExponentialCone</code></td></tr><tr><td style="text-align: right"><span>$A(x) \in \mathcal{S}_+$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: right"><span>$B(x) \in \mathcal{S}_+$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>PositiveSemidefiniteConeSquare</code></td></tr><tr><td style="text-align: right"><span>$x \in \mathcal{S}_+$</span></td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: right"><span>$x \in \mathcal{S}_+$</span></td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>PositiveSemidefiniteConeSquare</code></td></tr></table><p>where <span>$\mathcal{E}$</span> is the exponential cone (see <a href="../apireference/#MathOptInterface.ExponentialCone"><code>ExponentialCone</code></a>), <span>$\mathcal{S}_+$</span> is the set of positive semidefinite symmetric matrices, <span>$A$</span> is an affine map that outputs symmetric matrices and <span>$B$</span> is an affine map that outputs square matrices.</p><h4 id="Quadratic-constraints-1"><a class="docs-heading-anchor" href="#Quadratic-constraints-1">Quadratic constraints</a><a class="docs-heading-anchor-permalink" href="#Quadratic-constraints-1" title="Permalink"></a></h4><table><tr><th style="text-align: right">Mathematical Constraint</th><th style="text-align: right">MOI Function</th><th style="text-align: right">MOI Set</th></tr><tr><td style="text-align: right"><span>$x^TQx + a^Tx + b \ge 0$</span></td><td style="text-align: right"><code>ScalarQuadraticFunction</code></td><td style="text-align: right"><code>GreaterThan</code></td></tr><tr><td style="text-align: right"><span>$x^TQx + a^Tx + b \le 0$</span></td><td style="text-align: right"><code>ScalarQuadraticFunction</code></td><td style="text-align: right"><code>LessThan</code></td></tr><tr><td style="text-align: right"><span>$x^TQx + a^Tx + b = 0$</span></td><td style="text-align: right"><code>ScalarQuadraticFunction</code></td><td style="text-align: right"><code>EqualTo</code></td></tr><tr><td style="text-align: right">Bilinear matrix inequality</td><td style="text-align: right"><code>VectorQuadraticFunction</code></td><td style="text-align: right"><code>PositiveSemidefiniteCone...</code></td></tr></table><h4 id="Discrete-and-logical-constraints-1"><a class="docs-heading-anchor" href="#Discrete-and-logical-constraints-1">Discrete and logical constraints</a><a class="docs-heading-anchor-permalink" href="#Discrete-and-logical-constraints-1" title="Permalink"></a></h4><table><tr><th style="text-align: right">Mathematical Constraint</th><th style="text-align: right">MOI Function</th><th style="text-align: right">MOI Set</th></tr><tr><td style="text-align: right"><span>$x_i \in \mathbb{Z}$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>Integer</code></td></tr><tr><td style="text-align: right"><span>$x_i \in \{0,1\}$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>ZeroOne</code></td></tr><tr><td style="text-align: right"><span>$x_i \in \{0\} \cup [l,u]$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>Semicontinuous</code></td></tr><tr><td style="text-align: right"><span>$x_i \in \{0\} \cup \{l,l+1,\ldots,u-1,u\}$</span></td><td style="text-align: right"><code>SingleVariable</code></td><td style="text-align: right"><code>Semiinteger</code></td></tr><tr><td style="text-align: right">At most one component of <span>$x$</span> can be nonzero</td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>SOS1</code></td></tr><tr><td style="text-align: right">At most two components of <span>$x$</span> can be nonzero, and if so they must be adjacent components</td><td style="text-align: right"><code>VectorOfVariables</code></td><td style="text-align: right"><code>SOS2</code></td></tr><tr><td style="text-align: right"><span>$y = 1 \implies a^T x \in S$</span></td><td style="text-align: right"><code>VectorAffineFunction</code></td><td style="text-align: right"><code>IndicatorSet</code></td></tr></table><h2 id="Solving-and-retrieving-the-results-1"><a class="docs-heading-anchor" href="#Solving-and-retrieving-the-results-1">Solving and retrieving the results</a><a class="docs-heading-anchor-permalink" href="#Solving-and-retrieving-the-results-1" title="Permalink"></a></h2><p>Once an optimizer is loaded with the objective function and all of the constraints, we can ask the solver to solve the model by calling <a href="../apireference/#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><pre><code class="language-julia">optimize!(optimizer)</code></pre><p>The optimization procedure may terminate for a number of reasons. The <a href="../apireference/#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> attribute of the optimizer returns a <a href="../apireference/#MathOptInterface.TerminationStatusCode"><code>TerminationStatusCode</code></a> object which explains why the solver stopped. The termination statuses distinguish between proofs of optimality, infeasibility, local convergence, limits, and termination because of something unexpected like invalid problem data or failure to converge. A typical usage of the <code>TerminationStatus</code> attribute is as follows:</p><pre><code class="language-julia">status = MOI.get(optimizer, TerminationStatus())
if status == MOI.OPTIMAL
    # Ok, we solved the problem!
else
    # Handle other cases.
end</code></pre><p>After checking the <code>TerminationStatus</code>, one should typically check <a href="../apireference/#MathOptInterface.ResultCount"><code>ResultCount</code></a>. This attribute returns the number of results that the solver has available to return. <em>A result is defined as a primal-dual pair, but either the primal or the dual may be missing from the result.</em> While the <code>OPTIMAL</code> termination status normally implies that at least one result is available, other statuses do not. For example, in the case of infeasiblity, a solver may return no result or a proof of infeasibility. The <code>ResultCount</code> distinguishes between these two cases.</p><p>The <a href="../apireference/#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> and <a href="../apireference/#MathOptInterface.DualStatus"><code>DualStatus</code></a> attributes return a <a href="../apireference/#MathOptInterface.ResultStatusCode"><code>ResultStatusCode</code></a> that indicates if that component of the result is present (i.e., not <code>NO_SOLUTION</code>) and explains how to interpret the result.</p><p>If <code>PrimalStatus</code> is not <code>NO_SOLUTION</code>, then the primal may be retrieved with the <a href="../apireference/#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a> attribute:</p><pre><code class="language-julia">MOI.get(optimizer, VariablePrimal(), x)</code></pre><p>If <code>x</code> is a <code>VariableIndex</code> then the function call returns a scalar, and if <code>x</code> is a <code>Vector{VariableIndex}</code> then the call returns a vector of scalars. <code>VariablePrimal()</code> is equivalent to <code>VariablePrimal(1)</code>, i.e., the variable primal vector of the first result. Use <code>VariablePrimal(N)</code> to access the <code>N</code>th result.</p><p>See also the attributes <a href="../apireference/#MathOptInterface.ConstraintPrimal"><code>ConstraintPrimal</code></a>, and <a href="../apireference/#MathOptInterface.ConstraintDual"><code>ConstraintDual</code></a>. See <a href="#Duals-1">Duals</a> for a discussion of the MOI conventions for primal-dual pairs and certificates.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We omit discussion of how to handle multiple results, i.e., when <code>ResultCount</code> is greater than 1. This is supported in the API but not yet implemented in any solver.</p></div></div><h3 id="Common-status-situations-1"><a class="docs-heading-anchor" href="#Common-status-situations-1">Common status situations</a><a class="docs-heading-anchor-permalink" href="#Common-status-situations-1" title="Permalink"></a></h3><p>The sections below describe how to interpret typical or interesting status cases for three common classes of solvers. The example cases are illustrative, not comprehensive. Solver wrappers may provide additional information on how the solver&#39;s statuses map to MOI statuses.</p><p><code>?</code> in the tables indicate that multiple different values are possible.</p><h4 id="Primal-dual-convex-solver-1"><a class="docs-heading-anchor" href="#Primal-dual-convex-solver-1">Primal-dual convex solver</a><a class="docs-heading-anchor-permalink" href="#Primal-dual-convex-solver-1" title="Permalink"></a></h4><p>Linear programming and conic optimization solvers fall into this category.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Proved optimality</td><td style="text-align: right"><code>OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Proved infeasible</td><td style="text-align: right"><code>INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>INFEASIBILITY_CERTIFICATE</code></td></tr><tr><td style="text-align: right">Optimal within relaxed tolerances</td><td style="text-align: right"><code>ALMOST_OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code> or <code>ALMOST_FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code> or <code>ALMOST_FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Detected an unbounded ray of the primal</td><td style="text-align: right"><code>DUAL_INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBILITY_CERTIFICATE</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Stall</td><td style="text-align: right"><code>SLOW_PROGRESS</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr></table><h4 id="Global-branch-and-bound-solvers-1"><a class="docs-heading-anchor" href="#Global-branch-and-bound-solvers-1">Global branch-and-bound solvers</a><a class="docs-heading-anchor-permalink" href="#Global-branch-and-bound-solvers-1" title="Permalink"></a></h4><p>Mixed-integer programming solvers fall into this category.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Proved optimality</td><td style="text-align: right"><code>OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Presolve detected infeasibility or unboundedness</td><td style="text-align: right"><code>INFEASIBLE_OR_UNBOUNDED</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Proved infeasibility</td><td style="text-align: right"><code>INFEASIBLE</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Timed out (no solution)</td><td style="text-align: right"><code>TIME_LIMIT</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Timed out (with a solution)</td><td style="text-align: right"><code>TIME_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right"><code>CPXMIP_OPTIMAL_INFEAS</code></td><td style="text-align: right"><code>ALMOST_OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr></table><p><a href="https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.6.1/ilog.odms.cplex.help/refcallablelibrary/macros/CPXMIP_OPTIMAL_INFEAS.html"><code>CPXMIP_OPTIMAL_INFEAS</code></a> is a CPLEX status that indicates that a preprocessed problem was solved to optimality, but the solver was unable to recover a feasible solution to the original problem.</p><h4 id="Local-search-solvers-1"><a class="docs-heading-anchor" href="#Local-search-solvers-1">Local search solvers</a><a class="docs-heading-anchor-permalink" href="#Local-search-solvers-1" title="Permalink"></a></h4><p>Nonlinear programming solvers fall into this category. It also includes non-global tree search solvers like <a href="https://github.com/lanl-ansi/Juniper.jl">Juniper</a>.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Converged to a stationary point</td><td style="text-align: right"><code>LOCALLY_SOLVED</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Completed a non-global tree search (with a solution)</td><td style="text-align: right"><code>LOCALLY_SOLVED</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Converged to an infeasible point</td><td style="text-align: right"><code>LOCALLY_INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBLE_POINT</code></td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Completed a non-global tree search (no solution found)</td><td style="text-align: right"><code>LOCALLY_INFEASIBLE</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Iteration limit</td><td style="text-align: right"><code>ITERATION_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Diverging iterates</td><td style="text-align: right"><code>NORM_LIMIT</code> or <code>OBJECTIVE_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr></table><h2 id="A-complete-example:-solving-a-knapsack-problem-1"><a class="docs-heading-anchor" href="#A-complete-example:-solving-a-knapsack-problem-1">A complete example: solving a knapsack problem</a><a class="docs-heading-anchor-permalink" href="#A-complete-example:-solving-a-knapsack-problem-1" title="Permalink"></a></h2><p>We first need to select a solver supporting the given problem (see <a href="../apireference/#MathOptInterface.supports"><code>supports</code></a> and <a href="../apireference/#MathOptInterface.supports_constraint"><code>supports_constraint</code></a>). In this example, we want to solve a binary-constrained knapsack problem: <code>max c&#39;x: w&#39;x &lt;= C, x binary</code>. Suppose we choose GLPK:</p><pre><code class="language-julia">using GLPK
optimizer = GLPK.Optimizer()</code></pre><p>We first define the constants of the problem:</p><pre><code class="language-julia">c = [1.0, 2.0, 3.0]
w = [0.3, 0.5, 1.0]
C = 3.2

# output

3.2</code></pre><p>We create the variables of the problem and set the objective function:</p><pre><code class="language-julia">x = MOI.add_variables(optimizer, length(c))
objective_function = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0)
MOI.set(optimizer, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),
        objective_function)
MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)

# output

MAX_SENSE::OptimizationSense = 1</code></pre><p>We add the knapsack constraint and integrality constraints:</p><pre><code class="language-julia">knapsack_function = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0)
MOI.add_constraint(optimizer, knapsack_function, MOI.LessThan(C))
for x_i in x
    MOI.add_constraint(optimizer, MOI.SingleVariable(x_i), MOI.ZeroOne())
end

# output
</code></pre><p>We are all set! We can now call <a href="../apireference/#MathOptInterface.optimize!"><code>optimize!</code></a> and wait for the solver to find the solution:</p><pre><code class="language-julia">MOI.optimize!(optimizer)

# output
</code></pre><p>The first thing to check after optimization is why the solver stopped, e.g., did it stop because of a time limit or did it stop because it found the optimal solution?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.TerminationStatus())

# output


OPTIMAL::TerminationStatusCode = 1</code></pre><p>It found the optimal solution! Now let&#39;s see what is that solution.</p><pre><code class="language-julia">MOI.get(optimizer, MOI.PrimalStatus())

# output

FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>What is its objective value?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.ObjectiveValue())

# output

6.0</code></pre><p>And what is the value of the variables <code>x</code>?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.VariablePrimal(), x)

# output

3-element Array{Float64,1}:
 1.0
 1.0
 1.0</code></pre><h2 id="Problem-modification-1"><a class="docs-heading-anchor" href="#Problem-modification-1">Problem modification</a><a class="docs-heading-anchor-permalink" href="#Problem-modification-1" title="Permalink"></a></h2><p>In addition to adding and deleting constraints and variables, MathOptInterface supports modifying, in-place, coefficients in the constraints and the objective function of a model. These modifications can be grouped into two categories: modifications which replace the set of function of a constraint with a new set or function; and modifications which change, in-place, a component of a function.</p><p>In the following, we detail the various ways this can be achieved. Readers should note that some solvers will not support problem modification.</p><h3 id="Replacements-1"><a class="docs-heading-anchor" href="#Replacements-1">Replacements</a><a class="docs-heading-anchor-permalink" href="#Replacements-1" title="Permalink"></a></h3><p>First, we discuss how to replace the set or function of a constraint with a new instance of the same type.</p><h4 id="The-set-of-a-constraint-1"><a class="docs-heading-anchor" href="#The-set-of-a-constraint-1">The set of a constraint</a><a class="docs-heading-anchor-permalink" href="#The-set-of-a-constraint-1" title="Permalink"></a></h4><p>Given a constraint of type <code>F</code>-in-<code>S</code> (see <a href="#Constraints-by-function-set-pairs-1">Constraints by function-set pairs</a>  above for an explanation), we can modify parameters (but not the type) of the  set <code>S</code> by replacing it with a new instance of the same type. For example,  given the variable bound <span>$x \le 1$</span>:</p><pre><code class="language-julia">c = add_constraint(m, SingleVariable(x), LessThan(1.0))</code></pre><p>we can modify the set so that the bound now <span>$x \le 2$</span> as follows:</p><pre><code class="language-julia">set(m, ConstraintSet(), c, LessThan(2.0))</code></pre><p>where <code>m</code> is our <a href="../apireference/#MathOptInterface.ModelLike"><code>ModelLike</code></a> model. However, the following will fail as the new set (<code>GreaterThan</code>) is of a different type to the original set (<code>LessThan</code>):</p><pre><code class="language-julia">set(m, ConstraintSet(), c, GreaterThan(2.0))  # errors</code></pre><p>If our constraint is an affine inequality, then this corresponds to modifying the right-hand side of a constraint in linear programming.</p><p>In some special cases, solvers may support efficiently changing the set of a constraint (for example, from <a href="../apireference/#MathOptInterface.LessThan"><code>LessThan</code></a> to <a href="../apireference/#MathOptInterface.GreaterThan"><code>GreaterThan</code></a>). For these cases, MathOptInterface provides the <a href="../apireference/#MathOptInterface.transform"><code>transform</code></a> method. For example, instead of the error we observed above, the following will work:</p><pre><code class="language-julia">c2 = transform(m, c, GreaterThan(1.0))</code></pre><p>The <a href="../apireference/#MathOptInterface.transform"><code>transform</code></a> function returns a new constraint index, and the old constraint index (i.e., <code>c</code>) is no longer valid:</p><pre><code class="language-julia">is_valid(m, c)   # false
is_valid(m, c2)  # true</code></pre><p>Also note that <a href="../apireference/#MathOptInterface.transform"><code>transform</code></a> cannot be called with a set of the same type; <a href="../apireference/#MathOptInterface.set"><code>set</code></a> should be used instead.</p><h4 id="The-function-of-a-constraint-1"><a class="docs-heading-anchor" href="#The-function-of-a-constraint-1">The function of a constraint</a><a class="docs-heading-anchor-permalink" href="#The-function-of-a-constraint-1" title="Permalink"></a></h4><p>Given a constraint of type <code>F</code>-in-<code>S</code> (see <a href="#Constraints-by-function-set-pairs-1">Constraints by function-set pairs</a> above for an explanation), it is also  possible to modify the function of type <code>F</code> by replacing it with a new instance of the same type. For example, given the variable bound <span>$x \le 1$</span>:</p><pre><code class="language-julia">c = add_constraint(m, SingleVariable(x), LessThan(1.0))</code></pre><p>we can modify the function so that the bound now <span>$y \le 1$</span> as follows:</p><pre><code class="language-julia">set(m, ConstraintFunction(), c, SingleVariable(y))</code></pre><p>where <code>m</code> is our <a href="../apireference/#MathOptInterface.ModelLike"><code>ModelLike</code></a> model. However, the following will fail as the new function is of a different type to the original function:</p><pre><code class="language-julia">set(m, ConstraintFunction(), c,
    ScalarAffineFunction([ScalarAffineTerm(1.0, x)], 0.0)
)</code></pre><h3 id="In-place-modification-1"><a class="docs-heading-anchor" href="#In-place-modification-1">In-place modification</a><a class="docs-heading-anchor-permalink" href="#In-place-modification-1" title="Permalink"></a></h3><p>The second type of problem modifications allow the user to modify, in-place, the coefficients of a function. Currently, four modifications are supported by MathOptInterface. They are:</p><ol><li>change the constant term in a scalar function;</li><li>change the constant term in a vector function;</li><li>change the affine coefficients in a scalar function; and</li><li>change the affine coefficients in a vector function.</li></ol><p>To distinguish between the replacement of the function with a new instance (described above) and the modification of an existing function, the in-place modifications use the  <a href="../apireference/#MathOptInterface.modify"><code>modify</code></a> method:</p><pre><code class="language-julia">modify(model, index, change::AbstractFunctionModification)</code></pre><p><a href="../apireference/#MathOptInterface.modify"><code>modify</code></a> takes three arguments. The first is the <a href="../apireference/#MathOptInterface.ModelLike"><code>ModelLike</code></a> model <code>model</code>, the second is the constraint index, and the third is an instance of an <a href="../apireference/#MathOptInterface.AbstractFunctionModification"><code>AbstractFunctionModification</code></a>.</p><p>We now detail each of these four in-place modifications.</p><h4 id="Constant-term-in-a-scalar-function-1"><a class="docs-heading-anchor" href="#Constant-term-in-a-scalar-function-1">Constant term in a scalar function</a><a class="docs-heading-anchor-permalink" href="#Constant-term-in-a-scalar-function-1" title="Permalink"></a></h4><p>MathOptInterface supports is the ability to modify the constant term within a <a href="../apireference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a> and a <a href="../apireference/#MathOptInterface.ScalarQuadraticFunction"><code>ScalarQuadraticFunction</code></a> using the <a href="../apireference/#MathOptInterface.ScalarConstantChange"><code>ScalarConstantChange</code></a> subtype of <a href="../apireference/#MathOptInterface.AbstractFunctionModification"><code>AbstractFunctionModification</code></a>. This includes the objective function, as well as the function in a function-pair constraint.</p><p>For example, consider a problem <code>m</code> with the objective <span>$\max 1.0x + 0.0$</span>:</p><pre><code class="language-julia">set(m,
    ObjectiveFunction{ScalarAffineFunction{Float64}}(),
    ScalarAffineFunction([ScalarAffineTerm(1.0, x)], 0.0)
)</code></pre><p>We can modify the constant term in the objective function as follows:</p><pre><code class="language-julia">modify(m,
    ObjectiveFunction{ScalarAffineFunction{Float64}}(),
    ScalarConstantChange(1.0)
)</code></pre><p>The objective function will now be <span>$\max 1.0x + 1.0$</span>.</p><h4 id="Constant-terms-in-a-vector-function-1"><a class="docs-heading-anchor" href="#Constant-terms-in-a-vector-function-1">Constant terms in a vector function</a><a class="docs-heading-anchor-permalink" href="#Constant-terms-in-a-vector-function-1" title="Permalink"></a></h4><p>We can modify the constant terms in a <a href="../apireference/#MathOptInterface.VectorAffineFunction"><code>VectorAffineFunction</code></a> or a <a href="../apireference/#MathOptInterface.VectorQuadraticFunction"><code>VectorQuadraticFunction</code></a> using the <a href="../apireference/#MathOptInterface.VectorConstantChange"><code>VectorConstantChange</code></a> subtype of <a href="../apireference/#MathOptInterface.AbstractFunctionModification"><code>AbstractFunctionModification</code></a>.</p><p>For example, consider a model with the following <code>VectorAffineFunction</code>-in-<code>Nonpositives</code> constraint:</p><pre><code class="language-julia">c = add_constraint(m,
    VectorAffineFunction([
            VectorAffineTerm(1, ScalarAffineTerm(1.0, x)),
            VectorAffineTerm(1, ScalarAffineTerm(2.0, y))
        ],
        [0.0, 0.0]
    ),
    Nonpositives(2)
)</code></pre><p>We can modify the constant vector in the <a href="../apireference/#MathOptInterface.VectorAffineFunction"><code>VectorAffineFunction</code></a> from <code>[0.0, 0.0]</code> to <code>[1.0, 2.0]</code> as follows:</p><pre><code class="language-julia">modify(m, c, VectorConstantChange([1.0, 2.0])
)</code></pre><p>The constraints are now <span>$1.0x + 1.0 \le 0.0$</span> and <span>$2.0y + 2.0 \le 0.0$</span>.</p><h4 id="Affine-coefficients-in-a-scalar-function-1"><a class="docs-heading-anchor" href="#Affine-coefficients-in-a-scalar-function-1">Affine coefficients in a scalar function</a><a class="docs-heading-anchor-permalink" href="#Affine-coefficients-in-a-scalar-function-1" title="Permalink"></a></h4><p>In addition to modifying the constant terms in a function, we can also modify the affine variable coefficients in an <a href="../apireference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a> or a <a href="../apireference/#MathOptInterface.ScalarQuadraticFunction"><code>ScalarQuadraticFunction</code></a> using the <a href="../apireference/#MathOptInterface.ScalarCoefficientChange"><code>ScalarCoefficientChange</code></a> subtype of <a href="../apireference/#MathOptInterface.AbstractFunctionModification"><code>AbstractFunctionModification</code></a>.</p><p>For example, given the constraint <span>$1.0x &lt;= 1.0$</span>:</p><pre><code class="language-julia">c = add_constraint(m,
    ScalarAffineFunction([ScalarAffineTerm(1.0, x)], 0.0),
    LessThan(1.0)
)</code></pre><p>we can modify the coefficient of the <code>x</code> variable so that the constraint becomes <span>$2.0x &lt;= 1.0$</span> as follows:</p><pre><code class="language-julia">modify(m, c, ScalarCoefficientChange(x, 2.0))</code></pre><p><a href="../apireference/#MathOptInterface.ScalarCoefficientChange"><code>ScalarCoefficientChange</code></a> can also be used to modify the objective function by passing an instance of <a href="../apireference/#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> instead of the constraint index <code>c</code> as we saw above.</p><h4 id="Affine-coefficients-in-a-vector-function-1"><a class="docs-heading-anchor" href="#Affine-coefficients-in-a-vector-function-1">Affine coefficients in a vector function</a><a class="docs-heading-anchor-permalink" href="#Affine-coefficients-in-a-vector-function-1" title="Permalink"></a></h4><p>Finally, the last modification supported by MathOptInterface is the ability to modify the affine coefficients of a single variable in a <a href="../apireference/#MathOptInterface.VectorAffineFunction"><code>VectorAffineFunction</code></a> or a <a href="../apireference/#MathOptInterface.VectorQuadraticFunction"><code>VectorQuadraticFunction</code></a> using the <a href="../apireference/#MathOptInterface.MultirowChange"><code>MultirowChange</code></a> subtype of <a href="../apireference/#MathOptInterface.AbstractFunctionModification"><code>AbstractFunctionModification</code></a>.</p><p>For example, given the constraint <span>$Ax \in \mathbb{R}^2_+$</span>, where <span>$A = [1.0, 2.0]^\top$</span>:</p><pre><code class="language-julia">c = add_constraint(m,
    VectorAffineFunction([
            VectorAffineTerm(1, ScalarAffineTerm(1.0, x)),
            VectorAffineTerm(1, ScalarAffineTerm(2.0, x))
        ],
        [0.0, 0.0]
    ),
    Nonnegatives(2)
)</code></pre><p>we can modify the coefficients of the <code>x</code> variable so that the <code>A</code> matrix becomes <span>$A = [3.0, 4.0]^\top$</span> as follows:</p><pre><code class="language-julia">modify(m, c, MultirowChange(x, [3.0, 4.0]))</code></pre><h2 id="File-formats-1"><a class="docs-heading-anchor" href="#File-formats-1">File formats</a><a class="docs-heading-anchor-permalink" href="#File-formats-1" title="Permalink"></a></h2><p>The <code>FileFormats</code> module provides functionality for reading and writing MOI models using <a href="../apireference/#MathOptInterface.write_to_file"><code>write_to_file</code></a> and <a href="../apireference/#MathOptInterface.read_from_file"><code>read_from_file</code></a>.</p><p>To write a model <code>src</code> to a MathOptFormat file, use:</p><pre><code class="language-julia">src = # ...
dest = FileFormats.Model(format = FileFormats.FORMAT_MOF)
MOI.copy_to(dest, src)
MOI.write_to_file(dest, &quot;file.mof.json&quot;)</code></pre><p>The list of supported formats is given by the <a href="../apireference/#MathOptInterface.FileFormats.FileFormat"><code>FileFormats.FileFormat</code></a> enum.</p><p>Instead of the <code>format</code> keyword, you can also use the <code>filename</code> keyword argument to <a href="../apireference/#MathOptInterface.FileFormats.Model"><code>FileFormats.Model</code></a>. This will attempt to automatically guess the format from the file extension. For example:</p><pre><code class="language-julia">src = # ...
filename = &quot;my_model.cbf.gz&quot;
dest = FileFormats.Model(filename = filename)
MOI.copy_to(dest, src)
MOI.write_to_file(dest, filename)

src_2 = FileFormats.Model(filename = filename)
MOI.read_from_file(src_2, filename)</code></pre><p>Note how the compression format (GZip) is also automatically detected from the filename.</p><p>In some cases <code>src</code> may contain constraints that are not supported by the file format (e.g., the CBF format supports integer variables but not binary). If so, you should copy <code>src</code> to a bridged model using <a href="../apireference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a>:</p><pre><code class="language-julia">src = # ... conic model ...
dest = FileFormats.Model(format = FileFormats.FORMAT_CBF)
bridged = MOI.Bridges.full_bridge_optimizer(dest, Float64)
MOI.copy_to(bridged, src)
MOI.write_to_file(dest, &quot;my_model.cbf&quot;)</code></pre><p>You should also note that even after bridging, it may still not be possible to write the model to file because of unsupported constraints (e.g., PSD variables in the LP file format).</p><p>In addition to <a href="../apireference/#MathOptInterface.write_to_file"><code>write_to_file</code></a> and <a href="../apireference/#MathOptInterface.read_from_file"><code>read_from_file</code></a>, you can read and write directly from <code>IO</code> streams using <code>Base.write</code> and <code>Base.read!</code>:</p><pre><code class="language-julia">src = # ...
io = IOBuffer()
dest = FileFormats.Model(format = FileFormats.FORMAT_MPS)
MOI.copy_to(dest, src)
write(io, dest)

seekstart(io)
src_2 = FileFormats.Model(format = FileFormats.FORMAT_MPS)
read!(io, src_2)</code></pre><h2 id="Advanced-1"><a class="docs-heading-anchor" href="#Advanced-1">Advanced</a><a class="docs-heading-anchor-permalink" href="#Advanced-1" title="Permalink"></a></h2><h3 id="Duals-1"><a class="docs-heading-anchor" href="#Duals-1">Duals</a><a class="docs-heading-anchor-permalink" href="#Duals-1" title="Permalink"></a></h3><p>Conic duality is the starting point for MOI&#39;s duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem. For a minimization problem in geometric conic form, the primal is:</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is a maximization problem in standard conic form:</p><div>\[\begin{align}
&amp; \max_{y_1, \ldots, y_m} &amp; -\sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 - \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>where each <span>$\mathcal{C}_i$</span> is a closed convex cone and <span>$\mathcal{C}_i^*$</span> is its dual cone.</p><p>For a maximization problem in geometric conic form, the primal is:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is a minimization problem in standard conic form:</p><div>\[\begin{align}
&amp; \min_{y_1, \ldots, y_m} &amp; \sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 + \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>A linear inequality constraint <span>$a^T x + b \ge c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_+$</span>, and similarly <span>$a^T x + b \le c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_-$</span>. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of <span>$A_i$</span>.</p><p>For the special case of minimization LPs, the MOI primal form can be stated as</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:</p><div>\[\begin{align}
&amp; \max_{y_1,y_2,y_3} &amp; b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>For maximization LPs, the MOI primal form can be stated as:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>and similarly, the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1,y_2,y_3} &amp; -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = -a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>An important note for the LP case is that the signs of the feasible duals depend only on the sense of the inequality and not on the objective sense.</p><h4 id="Duality-and-scalar-product-1"><a class="docs-heading-anchor" href="#Duality-and-scalar-product-1">Duality and scalar product</a><a class="docs-heading-anchor-permalink" href="#Duality-and-scalar-product-1" title="Permalink"></a></h4><p>The scalar product is different from the canonical one for the sets <a href="../apireference/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>PositiveSemidefiniteConeTriangle</code></a>, <a href="../apireference/#MathOptInterface.LogDetConeTriangle"><code>LogDetConeTriangle</code></a>, <a href="../apireference/#MathOptInterface.RootDetConeTriangle"><code>RootDetConeTriangle</code></a>. If the set <span>$C_i$</span> of the section <a href="#Duals-1">Duals</a> is one of these three cones, then the rows of the matrix <span>$A_i$</span> corresponding to off-diagonal entries are twice the value of the <code>coefficients</code> field in the <code>VectorAffineFunction</code> for the corresponding rows. See <a href="../apireference/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>PositiveSemidefiniteConeTriangle</code></a> for details.</p><h4 id="Dual-for-problems-with-quadratic-functions-1"><a class="docs-heading-anchor" href="#Dual-for-problems-with-quadratic-functions-1">Dual for problems with quadratic functions</a><a class="docs-heading-anchor-permalink" href="#Dual-for-problems-with-quadratic-functions-1" title="Permalink"></a></h4><p>Given a problem with quadratic functions:</p><div>\[\begin{align*}
&amp; \min_{x \in \mathbb{R}^n} &amp; \frac{1}{2}x^TQ_0x + a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; \frac{1}{2}x^TQ_ix + a_i^T x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align*}\]</div><p>Consider the Lagrangian function</p><div>\[L(x, y) = \frac{1}{2}x^TQ_0x + a_0^T x + b_0 - \sum_{i = 1}^m y_i (\frac{1}{2}x^TQ_ix + a_i^T x + b_i)\]</div><p>A pair of primal-dual variables <span>$(x^\star, y^\star)$</span> is optimal if</p><ul><li><span>$x^\star$</span> is a minimizer of<div>\[\min_{x \in \mathbb{R}^n} L(x, y^\star).\]</div>That is,<div>\[0 = \nabla_x L(x, y^\star) = Q_0x + a_0 - \sum_{i = 1}^m y_i^\star (Q_ix + a_i).\]</div></li><li>and <span>$y^\star$</span> is a maximizer of<div>\[\max_{y_i \in \mathcal{C}_i^*} L(x^\star, y).\]</div>That is, for all <span>$i = 1, \ldots, m$</span>, <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span> is either zero or in the normal cone of <span>$\mathcal{C}_i^*$</span> at <span>$y^\star$</span>. For instance, if <span>$\mathcal{C}_i$</span> is <span>$\{ x \in \mathbb{R} : x \le 0 \}$</span>, it means that if <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span> is nonzero then <span>$\lambda_i = 0$</span>, this is the classical complementary slackness condition.</li></ul><p>If <span>$\mathcal{C}_i$</span> is a vector set, the discussion remains valid with <span>$y_i(\frac{1}{2}x^TQ_ix + a_i^T x + b_i)$</span> replaced with the scalar product between <code>y_i</code> and the vector of scalar-valued quadratic functions.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For quadratic programs with only affine constraints, the optimality condition <span>$\nabla_x L(x, y^\star) = 0$</span> can be simplified as follows</p><div>\[0 = \nabla_x L(x, y^\star) = Q_0x + a_0 - \sum_{i = 1}^m y_i^\star a_i\]</div><p>which gives</p><div>\[Q_0x = \sum_{i = 1}^m y_i^\star a_i - a_0\]</div><p>The Lagrangian function</p><div>\[L(x, y) = \frac{1}{2}x^TQ_0x + a_0^T x + b_0 - \sum_{i = 1}^m y_i (a_i^T x + b_i)\]</div><p>can be rewritten as</p><div>\[L(x, y) = \frac{1}{2}x^TQ_0x - (\sum_{i = 1}^m y_i a_i^T - a_0^T) x + b_0 - \sum_{i = 1}^m y_i (a_i^T x + b_i)\]</div><p>which, using the optimality condition <span>$\nabla_x L(x, y^\star) = 0$</span>, can be simplified as</p><div>\[L(x, y) = -\frac{1}{2}x^TQ_0x + b_0 - \sum_{i = 1}^m y_i (a_i^T x + b_i)\]</div></div></div><h3 id="Automatic-reformulation-1"><a class="docs-heading-anchor" href="#Automatic-reformulation-1">Automatic reformulation</a><a class="docs-heading-anchor-permalink" href="#Automatic-reformulation-1" title="Permalink"></a></h3><h4 id="Variable-reformulation-1"><a class="docs-heading-anchor" href="#Variable-reformulation-1">Variable reformulation</a><a class="docs-heading-anchor-permalink" href="#Variable-reformulation-1" title="Permalink"></a></h4><p>A variable is often created constrained in a set unsupported by the solver while it could be parametrized by variables constrained in supported sets. For example, the <a href="../apireference/#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>Bridges.Variable.VectorizeBridge</code></a> defines the reformulation of a constrained variable in <a href="../apireference/#MathOptInterface.GreaterThan"><code>GreaterThan</code></a> into a constrained vector of one variable in <a href="../apireference/#MathOptInterface.Nonnegatives"><code>Nonnegatives</code></a>. The <code>Bridges.Variable.Vectorize</code> is the bridge optimizer that applies the <a href="../apireference/#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>Bridges.Variable.VectorizeBridge</code></a> rewriting rule. Given an optimizer <code>optimizer</code> implementing constrained variables in <a href="../apireference/#MathOptInterface.Nonnegatives"><code>Nonnegatives</code></a>, the optimizer</p><pre><code class="language-julia">bridged_optimizer = MOI.Bridges.Variable.Vectorize{Float64}(optimizer)
MOI.supports_add_constrained_variable(bridged_optimizer, MOI.GreaterThan{Float64})

# output

true</code></pre><p>will additionally support constrained variables in <a href="../apireference/#MathOptInterface.GreaterThan"><code>GreaterThan</code></a>. Note that these <a href="../apireference/#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer"><code>Bridges.Variable.SingleBridgeOptimizer</code></a> are mainly used for testing bridges. It is recommended to rather use <a href="../apireference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a>, which automatically selects the appropriate bridges for unsupported constrained variables.</p><h4 id="Constraint-reformulation-1"><a class="docs-heading-anchor" href="#Constraint-reformulation-1">Constraint reformulation</a><a class="docs-heading-anchor-permalink" href="#Constraint-reformulation-1" title="Permalink"></a></h4><p>A constraint can often be written in a number of equivalent formulations. For example, the constraint <span>$l \le a^\top x \le u$</span> (<code>ScalarAffineFunction</code>-in-<code>Interval</code>) could be re-formulated as two constraints: <span>$a^\top x \ge l$</span> (<code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>) and <span>$a^\top x \le u$</span> (<code>ScalarAffineFunction</code>-in-<code>LessThan</code>). An alternative re-formulation is to add a dummy variable <code>y</code> with the constraints <span>$l \le y \le u$</span> (<code>SingleVariable</code>-in-<code>Interval</code>) and <span>$a^\top x - y = 0$</span> (<code>ScalarAffineFunction</code>-in-<code>EqualTo</code>).</p><p>To avoid each solver having to code these transformations manually, MathOptInterface provides <em>bridges</em>. A bridge is a small transformation from one constraint type to another (potentially collection of) constraint type. Because these bridges are included in MathOptInterface, they can be re-used by any optimizer. Some bridges also implement constraint modifications and constraint primal and dual translations.</p><p>For example, the <code>SplitIntervalBridge</code> defines the reformulation of a <code>ScalarAffineFunction</code>-in-<code>Interval</code> constraint into a <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code> and a <code>ScalarAffineFunction</code>-in-<code>LessThan</code> constraint. <code>SplitInterval</code> is the bridge optimizer that applies the <code>SplitIntervalBridge</code> rewriting rule. Given an optimizer <code>optimizer</code> implementing <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code> and <code>ScalarAffineFunction</code>-in-<code>LessThan</code>, the optimizer</p><pre><code class="language-julia">bridged_optimizer = MOI.Bridges.Constraint.SplitInterval{Float64}(optimizer)
MOI.supports_constraint(bridged_optimizer, MOI.ScalarAffineFunction{Float64}, MOI.Interval{Float64})

# output

true</code></pre><p>will additionally support <code>ScalarAffineFunction</code>-in-<code>Interval</code>. Note that these <a href="../apireference/#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>Bridges.Constraint.SingleBridgeOptimizer</code></a> are mainly used for testing bridges. It is recommended to rather use <a href="../apireference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> which automatically selects the appropriate constraint bridges for unsupported constraints.</p><h2 id="Implementing-a-solver-interface-1"><a class="docs-heading-anchor" href="#Implementing-a-solver-interface-1">Implementing a solver interface</a><a class="docs-heading-anchor-permalink" href="#Implementing-a-solver-interface-1" title="Permalink"></a></h2><p>[The interface is designed for multiple dispatch, e.g., attributes, combinations of sets and functions.]</p><h3 id="Solver-specific-attributes-1"><a class="docs-heading-anchor" href="#Solver-specific-attributes-1">Solver-specific attributes</a><a class="docs-heading-anchor-permalink" href="#Solver-specific-attributes-1" title="Permalink"></a></h3><p>Solver-specific attributes should be specified by creating an <a href="../apireference/#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>. For example, inside <code>MyPackage</code>, we could add the following:</p><pre><code class="language-julia">struct PrintLevel &lt;: MOI.AbstractOptimizerAttribute end
function MOI.set(model::Optimizer, ::PrintLevel, level::Int)
    # ... set the print level ...
end</code></pre><p>Then, the user can write:</p><pre><code class="language-julia">model = MyPackage.Optimizer()
MOI.set(model, MyPackage.PrintLevel(), 0)</code></pre><h3 id="Supported-constrained-variables-and-constraints-1"><a class="docs-heading-anchor" href="#Supported-constrained-variables-and-constraints-1">Supported constrained variables and constraints</a><a class="docs-heading-anchor-permalink" href="#Supported-constrained-variables-and-constraints-1" title="Permalink"></a></h3><p>The solver interface should only implement support for variables constrained on creation (see <a href="../apireference/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a>/<a href="../apireference/#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>) or constraints that directly map to a structure exploited by the solver algorithm. There is no need to add support for additional types, this is handled by the <a href="#Automatic-reformulation-1">Automatic reformulation</a>. Furthermore, this allows <a href="../apireference/#MathOptInterface.supports_constraint"><code>supports_constraint</code></a> to indicate which types are exploited by the solver and hence allows layers such as <a href="../apireference/#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> to accurately select the most appropriate transformations.</p><p>As <a href="../apireference/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> (resp. <a href="../apireference/#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>) falls back to <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a> (resp. <a href="../apireference/#MathOptInterface.add_variables"><code>add_variables</code></a>) followed by <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a>, there is no need to implement this function if <code>model</code> does not require that variables be constrained when they are created. However, if <code>model</code> requires that variables be constrained when they&#39;re created, then it should only implement <a href="../apireference/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> and not <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a> nor <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> for <a href="../apireference/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a>-in-<code>typeof(set)</code>. In addition, it should implement <code>supports_add_constrained_variables(::Optimizer, ::Type{Reals})</code> and return <code>false</code> so that these variables are bridged, see <a href="../apireference/#MathOptInterface.supports_add_constrained_variables"><code>supports_add_constrained_variables</code></a>.</p><h3 id="Handling-duplicate-coefficients-1"><a class="docs-heading-anchor" href="#Handling-duplicate-coefficients-1">Handling duplicate coefficients</a><a class="docs-heading-anchor-permalink" href="#Handling-duplicate-coefficients-1" title="Permalink"></a></h3><p>Solvers should expect that functions such as <code>ScalarAffineFunction</code> and <code>VectorQuadraticFunction</code> may contain duplicate coefficents, for example, <code>ScalarAffineFunction([ScalarAffineTerm(x, 1), ScalarAffineTerm(x, 1)], 0.0)</code>. These duplicate terms can be aggregated by calling <a href="../apireference/#MathOptInterface.Utilities.canonical"><code>Utilities.canonical</code></a>.</p><pre><code class="language-julia">x = MathOptInterface.VariableIndex(1)
term = MathOptInterface.ScalarAffineTerm(1, x)
func = MathOptInterface.ScalarAffineFunction([term, term], 0)
func_canon = MathOptInterface.Utilities.canonical(func)
func_canon ≈ MathOptInterface.ScalarAffineFunction(
    [MathOptInterface.ScalarAffineTerm(2, x)], 0)

# output

true</code></pre><h3 id="Implementing-copy-1"><a class="docs-heading-anchor" href="#Implementing-copy-1">Implementing copy</a><a class="docs-heading-anchor-permalink" href="#Implementing-copy-1" title="Permalink"></a></h3><p>Avoid storing extra copies of the problem when possible. This means that solver wrappers should not use <a href="../apireference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> as part of the wrapper. Instead, do one of the following to load the problem (assuming the solver wrapper type is called <code>Optimizer</code>):</p><ul><li><p>If the solver supports loading the problem incrementally, implement <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a>, <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> for supported constraints and <a href="../apireference/#MathOptInterface.set"><code>set</code></a> for supported attributes and add:</p><pre><code class="language-julia">function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>with</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::Optimizer, copy_names::Bool) = true</code></pre><p>or</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::Optimizer, copy_names::Bool) = !copy_names</code></pre><p>depending on whether the solver support names; see <a href="../apireference/#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a> for more details.</p></li><li><p>If the solver does not support loading the problem incrementally, do not implement <a href="../apireference/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../apireference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> as implementing them would require caching the problem. Let users or JuMP decide whether to use a <code>CachingOptimizer</code> instead. Write either a custom implementation of <a href="../apireference/#MathOptInterface.copy_to"><code>copy_to</code></a> or implement the <a href="../apireference/#Allocate-Load-API-1">Allocate-Load API</a>. If you choose to implement the Allocate-Load API, do</p><pre><code class="language-julia">function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>with</p><pre><code class="language-julia">MOI.Utilities.supports_allocate_load(model::Optimizer, copy_names::Bool) = true</code></pre><p>or</p><pre><code class="language-julia">MOI.Utilities.supports_allocate_load(model::Optimizer, copy_names::Bool) = !copy_names</code></pre><p>depending on whether the solver support names; see <a href="../apireference/#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> for more details.</p><p>Note that even if both writing a custom implementation of <a href="../apireference/#MathOptInterface.copy_to"><code>copy_to</code></a> and implementing the <a href="../apireference/#Allocate-Load-API-1">Allocate-Load API</a> requires the user to copy the model from a cache, the <a href="../apireference/#Allocate-Load-API-1">Allocate-Load API</a> allows MOI layers to be added between the cache and the solver which allows transformations to be applied without the need for additional caching. For instance, with the proposed <a href="https://github.com/JuliaOpt/MathOptInterface.jl/issues/523">Light bridges</a>, no cache will be needed to store the bridged model when bridges are used by JuMP so implementing the <a href="../apireference/#Allocate-Load-API-1">Allocate-Load API</a> will allow JuMP to use only one cache instead of two.</p></li></ul><h3 id="JuMP-mapping-1"><a class="docs-heading-anchor" href="#JuMP-mapping-1">JuMP mapping</a><a class="docs-heading-anchor-permalink" href="#JuMP-mapping-1" title="Permalink"></a></h3><p>MOI defines a very general interface, with multiple possible ways to describe the same constraint. This is considered a feature, not a bug. MOI is designed to make it possible to experiment with alternative representations of an optimization problem at both the solving and modeling level. When implementing an interface, it is important to keep in mind that the way the user can express problems in JuMP is not directly limited by the constraints which a solver supports via MOI as JuMP performs <a href="#Automatic-reformulation-1">Automatic reformulation</a>. Therefore, we recommend to only support the constraint types that directly map to a structure exploited by the solver algorithm. The following bullet points show examples of how JuMP constraints are translated into MOI function-set pairs:</p><ul><li><code>@constraint(m, 2x + y &lt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>LessThan</code>;</li><li><code>@constraint(m, 2x + y &gt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>;</li><li><code>@constraint(m, 2x + y == 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>EqualTo</code>;</li><li><code>@constraint(m, 0 &lt;= 2x + y &lt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>Interval</code>;</li><li><code>@constraint(m, 2x + y in ArbitrarySet())</code> becomes <code>ScalarAffineFunction</code>-in-<code>ArbitrarySet</code>.</li></ul><p>Variable bounds are handled in a similar fashion:</p><ul><li><code>@variable(m, x &lt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>LessThan</code>;</li><li><code>@variable(m, x &gt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>GreaterThan</code>.</li></ul><p>One notable difference is that a variable with an upper and lower bound is translated into two constraints, rather than an interval. i.e.:</p><ul><li><code>@variable(m, 0 &lt;= x &lt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>LessThan</code> <em>and</em> <code>SingleVariable</code>-in-<code>GreaterThan</code>.</li></ul><p>Solvers are not expected to support <code>AbstractScalarFunction</code> in <code>GreaterThan</code>, <code>LessThan</code>, <code>EqualTo</code>, or <code>Interval</code> with a nonzero constant in the function. Constants in the affine function should instead be moved into the parameters of the corresponding sets. The <a href="../apireference/#MathOptInterface.ScalarFunctionConstantNotZero"><code>ScalarFunctionConstantNotZero</code></a> exception may be thrown in this case.</p><h3 id="Column-Generation-1"><a class="docs-heading-anchor" href="#Column-Generation-1">Column Generation</a><a class="docs-heading-anchor-permalink" href="#Column-Generation-1" title="Permalink"></a></h3><p>There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver&#39;s API once all of the new coefficients are known.</p><h3 id="Problem-data-1"><a class="docs-heading-anchor" href="#Problem-data-1">Problem data</a><a class="docs-heading-anchor-permalink" href="#Problem-data-1" title="Permalink"></a></h3><p>All data passed to the solver should be copied immediately to internal data structures. Solvers may not modify any input vectors and should assume that input vectors may be modified by users in the future. This applies, for example, to the <code>terms</code> vector in <code>ScalarAffineFunction</code>. Vectors returned to the user, e.g., via <code>ObjectiveFunction</code> or <code>ConstraintFunction</code> attributes, should not be modified by the solver afterwards. The in-place version of <code>get!</code> can be used by users to avoid extra copies in this case.</p><h3 id="Statuses-1"><a class="docs-heading-anchor" href="#Statuses-1">Statuses</a><a class="docs-heading-anchor-permalink" href="#Statuses-1" title="Permalink"></a></h3><p>Solver wrappers should document how the low-level statuses map to the MOI statuses. Statuses like <code>NEARLY_FEASIBLE_POINT</code> and <code>INFEASIBLE_POINT</code>, are designed to be used when the solver explicitly indicates that relaxed tolerances are satisfied or the returned point is infeasible, respectively.</p><h3 id="Naming-1"><a class="docs-heading-anchor" href="#Naming-1">Naming</a><a class="docs-heading-anchor-permalink" href="#Naming-1" title="Permalink"></a></h3><p>MOI solver interfaces may be in the same package as the solver itself (either the C wrapper if the solver is accessible through C, or the Julia code if the solver is written in Julia, for example). The guideline for naming the file containing the MOI wrapper is <code>src/MOI_wrapper.jl</code> and <code>test/MOI_wrapper.jl</code> for the tests. If the MOI wrapper implementation is spread in several files, they should be stored in a <code>src/MOI_wrapper</code> folder and included by a <code>src/MOI_wrapper/MOI_wrapper.jl</code> file. In some cases it may be more appropriate to host the MOI wrapper in its own package; in this case it is recommended that the MOI wrapper package be named <code>MathOptInterfaceXXX</code> where <code>XXX</code> is the solver name.</p><p>By convention, optimizers should not be exported and should be named <code>PackageName.Optimizer</code>. For example, <code>CPLEX.Optimizer</code>, <code>Gurobi.Optimizer</code>, and <code>Xpress.Optimizer</code>.</p><h3 id="Testing-guideline-1"><a class="docs-heading-anchor" href="#Testing-guideline-1">Testing guideline</a><a class="docs-heading-anchor-permalink" href="#Testing-guideline-1" title="Permalink"></a></h3><p>The skeleton below can be used for the wrapper test file of a solver named <code>FooBar</code>.</p><pre><code class="language-julia">using Test

using MathOptInterface
const MOI = MathOptInterface
const MOIT = MOI.Test
const MOIU = MOI.Utilities
const MOIB = MOI.Bridges

import FooBar
const OPTIMIZER_CONSTRUCTOR = MOI.OptimizerWithAttributes(FooBar.Optimizer, MOI.Silent() =&gt; true)
const OPTIMIZER = MOI.instantiate(OPTIMIZER_CONSTRUCTOR)

@testset &quot;SolverName&quot; begin
    @test MOI.get(OPTIMIZER, MOI.SolverName()) == &quot;FooBar&quot;
end

@testset &quot;supports_default_copy_to&quot; begin
    @test MOIU.supports_default_copy_to(OPTIMIZER, false)
    # Use `@test !...` if names are not supported
    @test MOIU.supports_default_copy_to(OPTIMIZER, true)
end

const BRIDGED = MOI.instantiate(OPTIMIZER_CONSTRUCTOR, with_bridge_type = Float64)
const CONFIG = MOIT.TestConfig(atol=1e-6, rtol=1e-6)

@testset &quot;Unit&quot; begin
    MOIT.unittest(BRIDGED, CONFIG)
end

@testset &quot;Modification&quot; begin
    MOIT.modificationtest(BRIDGED, CONFIG)
end

@testset &quot;Continuous Linear&quot; begin
    MOIT.contlineartest(BRIDGED, CONFIG)
end

@testset &quot;Continuous Conic&quot; begin
    MOIT.contlineartest(BRIDGED, CONFIG)
end

@testset &quot;Integer Conic&quot; begin
    MOIT.intconictest(BRIDGED, CONFIG)
end</code></pre><p>The optimizer <code>BRIDGED</code> constructed with <a href="../apireference/#MathOptInterface.instantiate"><code>instantiate</code></a> automatically bridges constraints that are not supported by <code>OPTIMIZER</code> using the bridges listed in <a href="../apireference/#Bridges-1">Bridges</a>. It is recommended for an implementation of MOI to only support constraints that are natively supported by the solver and let bridges transform the constraint to the appropriate form. For this reason it is expected that tests may not pass if <code>OPTIMIZER</code> is used instead of <code>BRIDGED</code>.</p><p>To test that a specific problem can be solved without bridges, a specific test can be run with <code>OPTIMIZER</code> instead of <code>BRIDGED</code>. For instance</p><pre><code class="language-julia">@testset &quot;Interval constraints&quot; begin
    MOIT.linear10test(OPTIMIZER, CONFIG)
end</code></pre><p>checks that <code>OPTIMIZER</code> implements support for <a href="../apireference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>-in-<a href="../apireference/#MathOptInterface.Interval"><code>Interval</code></a>.</p><p>If the wrapper does not support building the model incrementally (i.e. with <code>add_variable</code> and <code>add_constraint</code>), then <code>supports_default_copy_to</code> can be replaced by <code>supports_allocate_load</code> if appropriate (see <a href="#Implementing-copy-1">Implementing copy</a>).</p><h3 id="Benchmarking-1"><a class="docs-heading-anchor" href="#Benchmarking-1">Benchmarking</a><a class="docs-heading-anchor-permalink" href="#Benchmarking-1" title="Permalink"></a></h3><p>To aid the development of efficient solver wrappers, MathOptInterface provides benchmarking functionality. Benchmarking a wrapper follows a two-step process.</p><p>First, prior to making changes, run and save the benchmark results on a given benchmark suite as follows:</p><pre><code class="language-julia">using SolverPackage, MathOptInterface

const MOI = MathOptInterface

suite = MOI.Benchmarks.suite() do
    SolverPackage.Optimizer()
end

MOI.Benchmarks.create_baseline(
    suite, &quot;current&quot;; directory = &quot;/tmp&quot;, verbose = true
)</code></pre><p>Use the <code>exclude</code> argument to <a href="../apireference/#MathOptInterface.Benchmarks.suite"><code>Benchmarks.suite</code></a> to exclude benchmarks that the solver doesn&#39;t support.</p><p>Second, after making changes to the package, re-run the benchmark suite and compare to the prior saved results:</p><pre><code class="language-julia">using SolverPackage, MathOptInterface

const MOI = MathOptInterface

suite = MOI.Benchmarks.suite() do
    SolverPackage.Optimizer()
end

MOI.Benchmarks.compare_against_baseline(
    suite, &quot;current&quot;; directory = &quot;/tmp&quot;, verbose = true
)</code></pre><p>This comparison will create a report detailing improvements and regressions.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../apireference/">Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 March 2020 10:32">Tuesday 24 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
