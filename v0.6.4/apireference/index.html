<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../apimanual/">Manual</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Model-Interface-1">Model Interface</a></li><li><a class="toctext" href="#Optimizers-1">Optimizers</a></li><li><a class="toctext" href="#Variables-and-Constraints-1">Variables and Constraints</a></li><li><a class="toctext" href="#Functions-and-function-modifications-1">Functions and function modifications</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Modifications-1">Modifications</a></li><li><a class="toctext" href="#Nonlinear-programming-(NLP)-1">Nonlinear programming (NLP)</a></li><li><a class="toctext" href="#Errors-1">Errors</a></li><li><a class="toctext" href="#Bridges-1">Bridges</a></li><li><a class="toctext" href="#Copy-utilities-1">Copy utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/master/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><p>[Some introduction to API. List basic standalone methods.]</p><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><p>List of attribute categories.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractOptimizerAttribute" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Note</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <code>AbstractModelAttribute</code> lies in the behavior of <code>is_empty</code>, <code>empty!</code> and <code>copy_to</code>. Typically optimizer attributes only affect how the model is solved.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L3-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractModelAttribute" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L30-L34">source</a></section><p>Attributes can be set in different ways:</p><ul><li>it is either set when the model is created like <a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>,</li><li>or explicitly when the model is copied like <a href="#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a>,</li><li>or implicitly, e.g., <a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> is implicitly set by <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> is implicitly set by <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</li><li>or it is set to contain the result of the optimization during <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> like <a href="#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a>.</li></ul><p>The following functions allow to distinguish between some of these different categories:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.is_set_by_optimize" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is modified during an <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p><strong>Important note when defining new attributes</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are modified by <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L825-L836">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.is_copyable" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Important note when defining new attributes</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>. A specific method should be defined for attibutes which are copied indirectly during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. For instance, both <code>is_copyable</code> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> return <code>false</code> for the following attributes:</p><ul><li><a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a>, <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a>, <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> and <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a>.</li><li><a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>: these attributes cannot be set.</li><li><a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> and <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>: these attributes are set indirectly by <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="#MathOptInterface.add_variables"><code>add_variables</code></a>.</li><li><a href="#MathOptInterface.ObjectiveFunctionType"><code>ObjectiveFunctionType</code></a>: this attribute is set indirectly when setting the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute.</li><li><a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a>, <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, <a href="#MathOptInterface.ListOfConstraints"><code>ListOfConstraints</code></a>, <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a>: these attributes are set indirectly by <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a> and <a href="#MathOptInterface.add_constraints"><code>add_constraints</code></a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L858-L884">source</a></section><p>Functions for getting and setting attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p><p><strong>Examples</strong></p><pre><code class="language-julia">get(model, ObjectiveValue())
get(model, VariablePrimal(), ref)
get(model, VariablePrimal(5), [ref1, ref2])
get(model, OtherAttribute(&quot;something specific to cplex&quot;))
get(model, VariableIndex, &quot;var1&quot;)
get(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
get(model, ConstraintIndex, &quot;con1&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L135-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <code>get</code>. The signature matches that of <code>get</code> except that the the result is placed in the vector <code>output</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L206-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.set" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><p><strong>Replace set in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{F,Interval}</code></p><pre><code class="language-julia">set(model, ConstraintSet(), c, Interval(0, 5))
set(model, ConstraintSet(), c, GreaterThan(0.0))  # Error</code></pre><p><strong>Replace function in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableIndex</code> objects,</p><pre><code class="language-julia">set(model, ConstraintFunction(), c, ScalarAffineFunction([v1,v2],[1.0,2.0],5.0))
set(model, ConstraintFunction(), c, SingleVariable(v1)) # Error</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L217-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all four methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOf...AttributesSet</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L79-L113">source</a></section><h2><a class="nav-anchor" id="Model-Interface-1" href="#Model-Interface-1">Model Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ModelLike" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d789231e9985537686052db9b2314c0d51656308/base/essentials.jl#L704-L717">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.write_to_file" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">write_to_file(model::ModelLike, filename::String)</code></pre><p>Writes the current model data to the given file. Supported file types depend on the model type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L34-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.read_from_file" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_from_file(model::ModelLike, filename::String)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, users can query the variables via <code>get(model, ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: <code>get(model, VariableIndex, &quot;name&quot;)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L42-L57">source</a></section><p>Copying</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.copy_to" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">copy_to(dest::ModelLike, src::ModelLike; copy_names=true, warn_attributes=true)</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>. The target <code>dest</code> is emptied, and all previous indices to variables or constraints in <code>dest</code> are invalidated. Returns a dictionary-like object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p>If <code>copy_names</code> is <code>false</code>, the <code>Name</code>, <code>VariableName</code> and <code>ConstraintName</code> attributes are not copied even if they are set in <code>src</code>. If a constraint that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown. Similarly, if a model, variable or constraint attribute that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown. Unsupported <em>optimizer</em> attributes are treated differently:</p><ul><li>If <code>warn_attributes</code> is <code>true</code>, a warning is displayed, otherwise,</li><li>the attribute is silently ignored.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L75-L108">source</a></section><p>List of model attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Name()</code></pre><p>A model attribute for the string identifying the model. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L345-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectiveSense()</code></pre><p>A model attribute for the <code>OptimizationSense</code> of the objective function, which can be <code>MinSense</code>, <code>MaxSense</code>, or <code>FeasiblitySense</code>. The default is <code>FeasibilitySense</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L353-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NumberOfVariables()</code></pre><p>A model attribute for the number of variables in the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L364-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfVariableIndices()</code></pre><p>A model attribute for the <code>Vector{VariableIndex}</code> of all variable indices present in the model (i.e., of length equal to the value of <code>NumberOfVariables()</code>) in the order in which they were added.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L371-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraints" href="#MathOptInterface.ListOfConstraints"><code>MathOptInterface.ListOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfConstraints()</code></pre><p>A model attribute for the list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L396-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NumberOfConstraints{F,S}()</code></pre><p>A model attribute for the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L389-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfConstraintIndices{F,S}()</code></pre><p>A model attribute for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>) in the order in which they were added.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L380-L386">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfOptimizerAttributesSet" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfOptimizerAttributesSet()</code></pre><p>An optimizer attribute for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L320-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfModelAttributesSet" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfModelAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L336-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfVariableAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L505-L511">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A model attribute for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and</p><ol><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L566-L577">source</a></section><h2><a class="nav-anchor" id="Optimizers-1" href="#Optimizers-1">Optimizers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractOptimizer" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractOptimizer</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L17-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/MathOptInterface.jl#L27-L31">source</a></section><p>List of attributes optimizers attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolverName" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SolverName()</code></pre><p>An optimizer attribute for the string identifying the solver/optimizer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L327-L331">source</a></section><p>List of attributes useful for optimizers</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RawSolver()</code></pre><p>A model attribute for the object that may be used to access a solver-specific API for this optimizer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L489-L493">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ResultCount()</code></pre><p>A model attribute for the number of results available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L496-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>A model attribute for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>. <code>F</code> should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g. the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L405-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveFunctionType" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectiveFunctionType()</code></pre><p>A model attribute for the type <code>F</code> of the objective function set using the <code>ObjectiveFunction{F}</code> attribute.</p><p><strong>Examples</strong></p><p>In the following code, <code>attr</code> should be equal to <code>MOI.SingleVariable</code>:</p><pre><code class="language-julia">x = MOI.add_variable(model)
MOI.set(model, MOI.ObjectiveFunction{MOI.SingleVariable}(),
         MOI.SingleVariable(x))
attr = MOI.get(model, MOI.ObjectiveFunctionType())</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L416-L431">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1)</code></pre><p>A model attribute for the objective value of the <code>resultindex</code>th primal result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L436-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>A model attribute for the best known bound on the optimal objective value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L446-L450">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RelativeGap()</code></pre><p>A model attribute for the final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L453-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SolveTime()</code></pre><p>A model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L460-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>A model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L467-L472">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>A model attribute for the cumulative number of barrier iterations while solving a problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L475-L479">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NodeCount()</code></pre><p>A model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L482-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A model attribute for the <code>TerminationStatusCode</code> explaining why the optimizer stopped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L687-L691">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L801-L807">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L813-L819">source</a></section><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute indicates why the optimizer stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OptimizeNotCalled</code>: the algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>Success</code>: the algorithm ran successfully and has a result; this includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility.</li><li><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a primal or dual result to return.</li><li><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a primal or dual result to return.</li><li><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded (no primal or dual result is available); this occasionally happens during MIP presolve.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>IterationLimit</code>: an iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TimeLimit</code>: the algorithm stopped after a user-specified computation time.</li><li><code>NodeLimit</code>: a branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SolutionLimit</code>: the algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MemoryLimit</code>: the algorithm stopped because it ran out of memory.</li><li><code>ObjectiveLimit</code>: the algorthm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NormLimit</code>: the algorithm stopped because the norm of an iterate became too large.</li><li><code>OtherLimit</code>: the algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied</li><li><code>NumericalError</code>: the algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>InvalidModel</code>: the algorithm stopped because the model is invalid.</li><li><code>InvalidOption</code>: the algorithm stopped because it was provided an invalid option.</li><li><code>Interrupted</code>: the algorithm stopped because of an interrupt signal.</li><li><code>OtherError</code>: the algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d789231e9985537686052db9b2314c0d51656308/base/#L0-L64">source</a></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes indicate how to interpret the result returned by the solver. The value of the attribute is of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NoSolution</code>: the result vector is empty.</li><li><code>FeasiblePoint</code>: the result vector is a feasible point.</li><li><code>NearlyFeasiblePoint</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>InfeasiblePoint</code>: the result vector is an infeasible point.</li><li><code>InfeasibilityCertificate</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>InfeasibilityCertificate</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>InfeasibilityCertificate</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NearlyInfeasibilityCertificate</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>UnknownResultStatus</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OtherResultStatus</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d789231e9985537686052db9b2314c0d51656308/base/#L0-L22">source</a></section><h2><a class="nav-anchor" id="Variables-and-Constraints-1" href="#Variables-and-Constraints-1">Variables and Constraints</a></h2><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><p>The <code>BasisStatus</code> attribute of a variable or constraint describes its status with respect to a basis, if one is known. The value of the attribute is of type <code>BasisStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attributes. This explains the status of a given element with respect to an optimal solution basis. Possible values are:</p><ul><li><code>Basic</code>: element is in the basis</li><li><code>Nonbasic</code>: element is not in the basis</li><li><code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound</li><li><code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound</li><li><code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d789231e9985537686052db9b2314c0d51656308/base/#L0-L11">source</a></section><h3><a class="nav-anchor" id="Index-types-1" href="#Index-types-1">Index types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableIndex" href="#MathOptInterface.VariableIndex"><code>MathOptInterface.VariableIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VariableIndex</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing variables in a model. To allow for deletion, indices need not be consecutive.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintIndex" href="#MathOptInterface.ConstraintIndex"><code>MathOptInterface.ConstraintIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintIndex{F,S}</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing <code>F</code>-in-<code>S</code> constraints in a model. The parameter <code>F</code> is the type of the function in the constraint, and the parameter <code>S</code> is the type of set in the constraint. To allow for deletion, indices need not be consecutive. Indices within a constraint type (i.e. <code>F</code>-in-<code>S</code>) must be unique, but non-unique indices across different constraint types are allowed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L3-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.is_valid" href="#MathOptInterface.is_valid"><code>MathOptInterface.is_valid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_valid(model::ModelLike, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the model <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L52-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}" href="#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}"><code>MathOptInterface.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">delete(model::ModelLike, index::Index)</code></pre><p>Delete the referenced object from the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L77-L81">source</a></section><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><p>Functions for adding variables. For deleting, see index types section.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.add_variables" href="#MathOptInterface.add_variables"><code>MathOptInterface.add_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_variables(model::ModelLike, n::Int)::Vector{VariableIndex}</code></pre><p>Add <code>n</code> scalar variables to the model, returning a vector of variable indices.</p><p>A <a href="#MathOptInterface.AddVariableNotAllowed"><code>AddVariableNotAllowed</code></a> error is thrown if adding variables cannot be done in the current state of the model <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/variables.jl#L17-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.add_variable" href="#MathOptInterface.add_variable"><code>MathOptInterface.add_variable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_variable(model::ModelLike)::VariableIndex</code></pre><p>Add a scalar variable to the model, returning a variable index.</p><p>A <a href="#MathOptInterface.AddVariableNotAllowed"><code>AddVariableNotAllowed</code></a> error is thrown if adding variables cannot be done in the current state of the model <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/variables.jl#L27-L34">source</a></section><p>List of attributes associated with variables. [category AbstractVariableAttribute] Calls to <code>get</code> and <code>set</code> should include as an argument a single <code>VariableIndex</code> or a vector of <code>VariableIndex</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableName" href="#MathOptInterface.VariableName"><code>MathOptInterface.VariableName</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VariableName()</code></pre><p>A variable attribute for a string identifying the variable. It is <em>valid</em> for two variables to have the same name; however, variables with duplicate names cannot be looked up using <a href="#MathOptInterface.get"><code>get</code></a>. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L514-L521">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>A variable attribute for the initial assignment to some primal variable&#39;s value that the optimizer may use to warm-start the solve.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L524-L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>A variable attribute for the assignment to some primal variable&#39;s value in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L531-L537">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableBasisStatus" href="#MathOptInterface.VariableBasisStatus"><code>MathOptInterface.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>A variable attribute for the <code>BasisStatusCode</code> of some variable, with respect to an available optimal solution basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L543-L547">source</a></section><h3><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h3><p>Functions for adding and modifying constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.ConstraintIndex}" href="#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.ConstraintIndex}"><code>MathOptInterface.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_valid(model::ModelLike, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the model <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L52-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.add_constraint" href="#MathOptInterface.add_constraint"><code>MathOptInterface.add_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_constraint(model::ModelLike, func::F, set::S)::ConstraintIndex{F,S} where {F,S}</code></pre><p>Add the constraint <span>$f(x) \in \mathcal{S}$</span> where <span>$f$</span> is defined by <code>func</code>, and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><pre><code class="language-none">add_constraint(model::ModelLike, v::VariableIndex, set::S)::ConstraintIndex{SingleVariable,S} where {S}
add_constraint(model::ModelLike, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}</code></pre><p>Add the constraint <span>$v \in \mathcal{S}$</span> where <span>$v$</span> is the variable (or vector of variables) referenced by <code>v</code> and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><p>An <a href="#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown if <code>model</code> does not support <code>F</code>-in-<code>S</code> constraints and a <a href="#MathOptInterface.AddConstraintNotAllowed"><code>AddConstraintNotAllowed</code></a> error is thrown if it supports <code>F</code>-in-<code>S</code> constraints but it cannot add the constraint(s) in its current state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L42-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.add_constraints" href="#MathOptInterface.add_constraints"><code>MathOptInterface.add_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_constraints(model::ModelLike, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}</code></pre><p>Add the set of constraints specified by each function-set pair in <code>funcs</code> and <code>sets</code>. <code>F</code> and <code>S</code> should be concrete types. This call is equivalent to <code>add_constraint.(model, funcs, sets)</code> but may be more efficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L106-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.transform" href="#MathOptInterface.transform"><code>MathOptInterface.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">transform(model::ModelLike, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}</code></pre><p>Replace the set in constraint <code>c</code> with <code>newset</code>. The constraint index <code>c</code> will no longer be valid, and the function returns a new constraint index with the correct type.</p><p>Solvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a <code>LessThan</code> to <code>GreaterThan</code> set). In addition, set modification (where <code>S1 = S2</code>) should be performed via the <code>modify</code> function.</p><p>Typically, the user should delete the constraint and add a new one.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">c2 = transform(model, c, GreaterThan(0.0))
transform(model, c, LessThan(0.0)) # errors</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L117-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.supports_constraint" href="#MathOptInterface.supports_constraint"><code>MathOptInterface.supports_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MOI.supports_constraint(BT::Type{&lt;:AbstractBridge}, F::Type{&lt;:MOI.AbstractFunction}, S::Type{&lt;:MOI.AbstractSet})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> support bridging <code>F</code>-in-<code>S</code> constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/bridge.jl#L33-L37">source</a><div><div><pre><code class="language-none">supports_constraint(model::ModelLike, ::Type{F}, ::Type{S})::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <code>F</code>-in-<code>S</code> constraints, that is, <code>copy_to(model, src)</code> does not return <code>CopyUnsupportedConstraint</code> when <code>src</code> contains <code>F</code>-in-<code>S</code> constraints. If <code>F</code>-in-<code>S</code> constraints are only not supported in specific circumstances, e.g. <code>F</code>-in-<code>S</code> constraints cannot be combined with another type of constraint, it should still return <code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L3-L9">source</a></section><p>List of attributes associated with constraints. [category AbstractConstraintAttribute] Calls to <code>get</code> and <code>set</code> should include as an argument a single <code>ConstraintIndex</code> or a vector of <code>ConstraintIndex{F,S}</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintName" href="#MathOptInterface.ConstraintName"><code>MathOptInterface.ConstraintName</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintName()</code></pre><p>A constraint attribute for a string identifying the constraint. It is <em>valid</em> for constraints variables to have the same name; however, constraints with duplicate names cannot be looked up using <a href="#MathOptInterface.get"><code>get</code></a> regardless of if they have the same <code>F</code>-in<code>S</code> type. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L580-L587">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>A constraint attribute for the initial assignment to some constraint&#39;s primal value(s) that the optimizer may use to warm-start the solve.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L590-L594">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>A constraint attribute for the initial assignment to some constraint&#39;s dual value(s) that the optimizer may use to warm-start the solve.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L597-L601">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>A constraint attribute for the assignment to some constraint&#39;s primal value(s) in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p><p>Given a constraint <code>function-in-set</code>, the <code>ConstraintPrimal</code> is the value of the function evaluated at the primal solution of the variables. For example, given the constraint <code>ScalarAffineFunction([x,y], [1, 2], 3)</code>-in-<code>Interval(0, 20)</code> and a primal solution of <code>(x,y) = (4,5)</code>, the <code>ConstraintPrimal</code> solution of the constraint is <code>1 * 4 + 2 * 5 + 3 = 17</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L604-L616">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>A constraint attribute for the assignment to some constraint&#39;s dual value(s) in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L622-L628">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>A constraint attribute for the <code>BasisStatusCode</code> of some constraint, with respect to an available optimal solution basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L634-L638">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintFunction" href="#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintFunction()</code></pre><p>A constraint attribute for the <code>AbstractFunction</code> object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L641-L646">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintSet" href="#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstraintSet()</code></pre><p>A constraint attribute for the <code>AbstractSet</code> object used to define the constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L664-L668">source</a></section><h2><a class="nav-anchor" id="Functions-and-function-modifications-1" href="#Functions-and-function-modifications-1">Functions and function modifications</a></h2><p>List of recognized functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractFunction" href="#MathOptInterface.AbstractFunction"><code>MathOptInterface.AbstractFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractFunction</code></pre><p>Abstract supertype for function objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SingleVariable" href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SingleVariable(variable)</code></pre><p>The function that extracts the scalar variable referenced by <code>variable</code>, a <code>VariableIndex</code>. This function is naturally be used for single variable bounds or integrality constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L34-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorOfVariables" href="#MathOptInterface.VectorOfVariables"><code>MathOptInterface.VectorOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorOfVariables(variables)</code></pre><p>The function that extracts the vector of variables referenced by <code>variables</code>, a <code>Vector{VariableIndex}</code>. This function is naturally be used for constraints that apply to groups of variables, such as an &quot;all different&quot; constraint, an indicator constraint, or a complementarity constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L44-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarAffineTerm" href="#MathOptInterface.ScalarAffineTerm"><code>MathOptInterface.ScalarAffineTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ScalarAffineTerm{T}
    coefficient::T
    variable_index::VariableIndex
end</code></pre><p>Represents <span>$c x_i$</span> where <span>$c$</span> is <code>coefficient</code> and <span>$x_i$</span> is the variable identified by <code>variable_index</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L55-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarAffineFunction" href="#MathOptInterface.ScalarAffineFunction"><code>MathOptInterface.ScalarAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarAffineFunction{T}(terms, constant)</code></pre><p>The scalar-valued affine function <span>$a^T x + b$</span>, where:</p><ul><li><span>$a$</span> is a sparse vector specified by a list of <a href="#MathOptInterface.ScalarAffineTerm"><code>ScalarAffineTerm</code></a> structs.</li><li><span>$b$</span> is a scalar specified by <code>constant::T</code></li></ul><p>Duplicate variable indices in <code>terms</code> are accepted, and the corresponding coefficients are summed together.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L73-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorAffineTerm" href="#MathOptInterface.VectorAffineTerm"><code>MathOptInterface.VectorAffineTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct VectorAffineTerm{T}
    output_index::Int64
    scalar_term::ScalarAffineTerm{T}
end</code></pre><p>A <code>ScalarAffineTerm</code> plus its index of the output component of a <code>VectorAffineFunction</code> or <code>VectorQuadraticFunction</code>. <code>output_index</code> can also be interpreted as a row index into a sparse matrix, where the <code>scalar_term</code> contains the column index and coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L89-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorAffineFunction" href="#MathOptInterface.VectorAffineFunction"><code>MathOptInterface.VectorAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorAffineFunction{T}(terms, constants)</code></pre><p>The vector-valued affine function <span>$A x + b$</span>, where:</p><ul><li><span>$A$</span> is a sparse matrix specified by a list of <code>VectorAffineTerm</code> objects.</li><li><span>$b$</span> is a vector specified by <code>constants</code></li></ul><p>Duplicate indices in the <span>$A$</span> are accepted, and the corresponding coefficients are summed together.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L109-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticTerm" href="#MathOptInterface.ScalarQuadraticTerm"><code>MathOptInterface.ScalarQuadraticTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ScalarQuadraticTerm{T}
    coefficient::T
    variable_index_1::VariableIndex
    variable_index_2::VariableIndex
end</code></pre><p>Represents <span>$c x_i x_j$</span> where <span>$c$</span> is <code>coefficient</code>, <span>$x_i$</span> is the variable identified by <code>variable_index_1</code> and <span>$x_j$</span> is the variable identified by <code>variable_index_2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L125-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticFunction" href="#MathOptInterface.ScalarQuadraticFunction"><code>MathOptInterface.ScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarQuadraticFunction{T}(affine_terms, quadratic_terms, constant)</code></pre><p>The scalar-valued quadratic function <span>$\frac{1}{2}x^TQx + a^T x + b$</span>, where:</p><ul><li><span>$a$</span> is a sparse vector specified by a list of <code>ScalarAffineTerm</code> structs.</li><li><span>$b$</span> is a scalar specified by <code>constant</code>.</li><li><span>$Q$</span> is a symmetric matrix specified by a list of <code>ScalarQuadraticTerm</code> structs.</li></ul><p>Duplicate indices in <span>$a$</span> or <span>$Q$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L146-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorQuadraticTerm" href="#MathOptInterface.VectorQuadraticTerm"><code>MathOptInterface.VectorQuadraticTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct VectorQuadraticTerm{T}
    output_index::Int64
    scalar_term::ScalarQuadraticTerm{T}
end</code></pre><p>A <a href="#MathOptInterface.ScalarQuadraticTerm"><code>ScalarQuadraticTerm</code></a> plus its index of the output component of a <code>VectorQuadraticFunction</code>. Each output component corresponds to a distinct sparse matrix <span>$Q_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L166-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorQuadraticFunction" href="#MathOptInterface.VectorQuadraticFunction"><code>MathOptInterface.VectorQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorQuadraticFunction{T}(affine_terms, quadratic_terms, constant)</code></pre><p>The vector-valued quadratic function with i<code>th</code> component (&quot;output index&quot;) defined as <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span>, where:</p><ul><li><span>$a_i$</span> is a sparse vector specified by the <code>VectorAffineTerm</code>s with <code>output_index == i</code>.</li><li><span>$b_i$</span> is a scalar specified by <code>constants[i]</code></li><li><span>$Q_i$</span> is a symmetric matrix specified by the <code>VectorQuadraticTerm</code> with <code>output_index == i</code>.</li></ul><p>Duplicate indices in <span>$a_i$</span> or <span>$Q_i$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L186-L201">source</a></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.output_dimension" href="#MathOptInterface.output_dimension"><code>MathOptInterface.output_dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">output_dimension(f::AbstractFunction)</code></pre><p>Return 1 if <code>f</code> has a scalar output and the number of output components if <code>f</code> has a vector output.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L10-L15">source</a></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of recognized sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Reals(dimension)</code></pre><p>The set <span>$\mathbb{R}^{dimension}$</span> (containing all points) of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Zeros(dimension)</code></pre><p>The set <span>$\{ 0 \}^{dimension}$</span> (containing only the origin) of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonnegatives" href="#MathOptInterface.Nonnegatives"><code>MathOptInterface.Nonnegatives</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Nonnegatives(dimension)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L67-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonpositives" href="#MathOptInterface.Nonpositives"><code>MathOptInterface.Nonpositives</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Nonpositives(dimension)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \le 0 \}$</span> of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L76-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GreaterThan{T &lt;: Real}(lower::T)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LessThan{T &lt;: Real}(upper::T)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L94-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.EqualTo" href="#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EqualTo{T &lt;: Number}(value::T)</code></pre><p>The set containing the single point <span>$x \in \mathbb{R}$</span> where <span>$x$</span> is given by <code>value</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L103-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interval{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <code>lower</code> or <code>upper</code> is <code>-Inf</code> or <code>Inf</code>, respectively, the set is interpreted as a one-sided interval.</p><pre><code class="language-none">Interval(s::GreaterThan{&lt;:AbstractFloat})</code></pre><p>Construct a (right-unbounded) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.GreaterThan"><code>GreaterThan</code></a> set.</p><pre><code class="language-none">Interval(s::LessThan{&lt;:AbstractFloat})</code></pre><p>Construct a (left-unbounded) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.LessThan"><code>LessThan</code></a> set.</p><pre><code class="language-none">Interval(s::EqualTo{&lt;:Real})</code></pre><p>Construct a (degenerate) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.EqualTo"><code>EqualTo</code></a> set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L112-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SecondOrderCone(dimension)</code></pre><p>The second-order cone (or Lorenz cone) <span>$\{ (t,x) \in \mathbb{R}^{dimension} : t \ge || x ||_2 \}$</span> of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RotatedSecondOrderCone" href="#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RotatedSecondOrderCone(dimension)</code></pre><p>The rotated second-order cone <span>$\{ (t,u,x) \in \mathbb{R}^{dimension} : 2tu \ge || x ||_2^2, t,u \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L148-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GeometricMeanCone" href="#MathOptInterface.GeometricMeanCone"><code>MathOptInterface.GeometricMeanCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GeometricMeanCone(dimension)</code></pre><p>The geometric mean cone <span>$\{ (t,x) \in \mathbb{R}^{n+1} : x \ge 0, t \le \sqrt[n]{x_1 x_2 \cdots x_n} \}$</span> of dimension <code>dimension</code><span>${}=n+1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L157-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L166-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L173-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{exponent} y^{1-exponent} &gt;= |z|, x \ge 0, y \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L180-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DualPowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (\frac{u}{exponent})^{exponent} (\frac{v}{1-exponent})^{1-exponent} \ge |w|, u \ge 0, v \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L189-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PositiveSemidefiniteConeTriangle(side_dimension)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with <code>side_dimension</code> rows and columns. The entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row). A vectorized cone of <a href="#MathOptInterface.dimension"><code>dimension</code></a> <span>$n$</span> corresponds to a square matrix with side dimension <span>$\sqrt{1/4 + 2 n} - 1/2$</span>. (Because a <span>$d \times d$</span> matrix has <span>$d(d+1)/2$</span> elements in the upper or lower triangle.)</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 4\\
  2 &amp; 3 &amp; 5\\
  4 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>corresponds to <span>$(1, 2, 3, 4, 5, 6)$</span> for <code>PositiveSemidefiniteConeTriangle(3)</code></p><p><strong>Note</strong></p><p>Two packed storage formats exist for symmetric matrices, the respective orders of the entries are:</p><ul><li>upper triangular column by column (or lower triangular row by row);</li><li>lower triangular column by column (or upper triangular row by row).</li></ul><p>The advantage of the first format is the mapping between the <code>(i, j)</code> matrix indices and the <code>k</code> index of the vectorized form. It is simpler and does not depend on the side dimension of the matrix. Indeed,</p><ul><li>the entry of matrix indices <code>(i, j)</code> has vectorized index <code>k = div((j-1)*j, 2) + i</code> if <span>$i \leq j$</span> and <code>k = div((i-1)*i, 2) + j</code> if <span>$j \leq i$</span>;</li><li>and the entry with vectorized index <code>k</code> has matrix indices <code>i = isqrt(2k)</code> and <code>j = k - div((i-1)*i, 2)</code> or <code>j = isqrt(2k)</code> and <code>i = k - div((j-1)*j, 2)</code>.</li></ul><p><strong>Duality note</strong></p><p>The scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality. Consider for example the following problem</p><div>\[\begin{align*}
    &amp; \max_{x \in \mathbb{R}} &amp; x
    \\
    &amp; \;\;\text{s.t.} &amp;
    (1, -x, 1) &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</div><p>The dual is the following problem</p><div>\[\begin{align*}
    &amp; \min_{x \in \mathbb{R}^3} &amp; y_1 + y_3
    \\
    &amp; \;\;\text{s.t.} &amp; 2y_2 &amp; = 1\\
    &amp; &amp; y &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</div><p>Why do we use <span>$2y_2$</span> in the dual constraint instead of <span>$y_2$</span> ? The reason is that <span>$2y_2$</span> is the scalar product between <span>$y$</span> and the symmetric matrix whose vectorized form is <span>$(0, 1, 0)$</span>. Indeed, with our modified scalar products we have</p><div>\[\langle
(0, 1, 0),
(y_1, y_2, y_3)
\rangle
=
\mathrm{trace}
\begin{pmatrix}
  0 &amp; 1\\
  1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
  y_1 &amp; y_2\\
  y_2 &amp; y_3
\end{pmatrix}
= 2y_2.\]</div><p><strong>References</strong></p><p>[1] Boyd, S. and Vandenberghe, L.. <em>Convex optimization</em>. Cambridge university press, 2004.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L200-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeSquare" href="#MathOptInterface.PositiveSemidefiniteConeSquare"><code>MathOptInterface.PositiveSemidefiniteConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PositiveSemidefiniteConeSquare(side_dimension)</code></pre><p>The cone of symmetric positive semidefinite matrices, with side length <code>side_dimension</code>. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to be positive semidefinite. That is, if the functions in entries <span>$(i, j)$</span> and <span>$(j, i)$</span> are different, then a constraint will be added to make sure that the entries are equal.</p><p><strong>Examples</strong></p><p>Constraining the matrix</p><div>\[\begin{bmatrix}
  1 &amp; -y\\
  -z &amp; 0\\
\end{bmatrix}\]</div><p>to be symmetric positive semidefinite can be achieved by constraining the vector <span>$(1, -z, -y, 0)$</span> (or <span>$(1, -y, -z, 0)$</span>) to belong to the <code>PositiveSemidefiniteConeSquare(2)</code>. It both constrains <span>$y = z$</span> and <span>$(1, -y, 0)$</span> (or <span>$(1, -z, 0)$</span>) to be in <code>PositiveSemidefiniteConeTriangle(2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L283-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LogDetConeTriangle" href="#MathOptInterface.LogDetConeTriangle"><code>MathOptInterface.LogDetConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LogDetConeTriangle(side_dimension)</code></pre><p>The Log-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d(d+1)/2} : t \le \log(\det(X)) \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L310-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LogDetConeSquare" href="#MathOptInterface.LogDetConeSquare"><code>MathOptInterface.LogDetConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LogDetConeSquare(side_dimension)</code></pre><p>The Log-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d^2} : t \le \log(\det(X)), X \text{ symmetric} \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensures that <code>X</code> is symmetric. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L320-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RootDetConeTriangle" href="#MathOptInterface.RootDetConeTriangle"><code>MathOptInterface.RootDetConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RootDetConeTriangle(side_dimension)</code></pre><p>The Root-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d(d+1)/2} : t \le \det(X)^{1/d} \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L331-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RootDetConeSquare" href="#MathOptInterface.RootDetConeSquare"><code>MathOptInterface.RootDetConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RootDetConeSquare(side_dimension)</code></pre><p>The Root-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d^2} : t \le \det(X)^{1/d}, X \text{ symmetric} \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensure that <code>X</code> is symmetric. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L341-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Integer" href="#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Integer()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L356-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L363-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semicontinuous" href="#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Semicontinuous{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup [lower,upper]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L370-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semiinteger" href="#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Semiinteger{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup \{lower,lower+1,\ldots,upper-1,upper\}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L380-L384">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SOS1{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L390-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SOS2{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L406-L414">source</a></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dimension(s::AbstractSet)</code></pre><p>Return the <a href="#MathOptInterface.output_dimension"><code>output_dimension</code></a> that an <a href="#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> should have to be used with the set <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dimension(Reals(4))
4

julia&gt; dimension(LessThan(3.0))
1

julia&gt; dimension(PositiveSemidefiniteConeTriangle(2))
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/sets.jl#L10-L28">source</a></section><h2><a class="nav-anchor" id="Modifications-1" href="#Modifications-1">Modifications</a></h2><p>Functions for modifying objective and constraint functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modify" href="#MathOptInterface.modify"><code>MathOptInterface.modify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Constraint Function</strong></p><pre><code class="language-none">modify(model::ModelLike, ci::ConstraintIndex, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the function of constraint <code>ci</code>.</p><p>An <a href="#MathOptInterface.ModifyConstraintNotAllowed"><code>ModifyConstraintNotAllowed</code></a> error is thrown if modifying constraints is not supported by the model <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modify(model, ci, ScalarConstantChange(10.0))</code></pre><p><strong>Objective Function</strong></p><pre><code class="language-none">modify(model::ModelLike, ::ObjectiveFunction, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the objective function of <code>model</code>. To change the function completely, call <code>set</code> instead.</p><p>An <a href="#MathOptInterface.ModifyObjectiveNotAllowed"><code>ModifyObjectiveNotAllowed</code></a> error is thrown if modifying objectives is not supported by the model <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modify(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(), ScalarConstantChange(10.0))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/modifications.jl#L44-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractFunctionModification" href="#MathOptInterface.AbstractFunctionModification"><code>MathOptInterface.AbstractFunctionModification</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractFunctionModification</code></pre><p>An abstract supertype for structs which specify partial modifications to functions, to be used for making small modifications instead of replacing the functions entirely.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L212-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarConstantChange" href="#MathOptInterface.ScalarConstantChange"><code>MathOptInterface.ScalarConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarConstantChange{T}(new_constant::T)</code></pre><p>A struct used to request a change in the constant term of a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L219-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorConstantChange" href="#MathOptInterface.VectorConstantChange"><code>MathOptInterface.VectorConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorConstantChange{T}(new_constant::Vector{T})</code></pre><p>A struct used to request a change in the constant vector of a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L229-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarCoefficientChange" href="#MathOptInterface.ScalarCoefficientChange"><code>MathOptInterface.ScalarCoefficientChange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarCoefficientChange{T}(variable::VariableIndex, new_coefficient::T)</code></pre><p>A struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L239-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.MultirowChange" href="#MathOptInterface.MultirowChange"><code>MathOptInterface.MultirowChange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MultirowChange{T}(variable::VariableIndex, new_coefficients::Vector{Tuple{Int64, T}})</code></pre><p>A struct used to request a change in the linear coefficients of a single variable in a vector-valued function. New coefficients are specified by <code>(output_index, coefficient)</code> tuples. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/functions.jl#L255-L262">source</a></section><h2><a class="nav-anchor" id="Nonlinear-programming-(NLP)-1" href="#Nonlinear-programming-(NLP)-1">Nonlinear programming (NLP)</a></h2><h3><a class="nav-anchor" id="Attributes-2" href="#Attributes-2">Attributes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NLPBlock" href="#MathOptInterface.NLPBlock"><code>MathOptInterface.NLPBlock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NLPBlock()</code></pre><p>Holds the <code>NLPBlockData</code> that represents a set of nonlinear constraints, and optionally a nonlinear objective.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NLPBoundsPair" href="#MathOptInterface.NLPBoundsPair"><code>MathOptInterface.NLPBoundsPair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NLPBoundsPair(lower,upper)</code></pre><p>A struct holding a pair of lower and upper bounds. <code>-Inf</code> and <code>Inf</code> can be used to indicate no lower or upper bound, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L46-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NLPBlockData" href="#MathOptInterface.NLPBlockData"><code>MathOptInterface.NLPBlockData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct NLPBlockData
    constraint_bounds::Vector{NLPBoundsPair}
    evaluator::AbstractNLPEvaluator
    has_objective::Bool
end</code></pre><p>A <code>struct</code> encoding a set of nonlinear constraints of the form <span>$lb \le g(x) \le ub$</span> and, if <code>has_objective == true</code>, a nonlinear objective function <span>$f(x)$</span>. <code>constraint_bounds</code> holds the pairs of <span>$lb$</span> and <span>$ub$</span> elements. It is an error to set both a nonlinear objective function and another objective function using an <code>ObjectiveFunction</code> attribute. The <code>evaluator</code> is a callback object that is used to query function values, derivatives, and expression graphs. If <code>has_objective == false</code>, then it is an error to query properties of the objective function, and in Hessian-of-the-Lagrangian queries, <code>σ</code> must be set to zero. Throughout the evaluator, all variables are ordered according to ListOfVariableIndices(). </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L58-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NLPBlockDual" href="#MathOptInterface.NLPBlockDual"><code>MathOptInterface.NLPBlockDual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NLPBlockDual(N)
NLPBlockDual()</code></pre><p>The Lagrange multipliers on the constraints from the <code>NLPBlock</code> in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L24-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NLPBlockDualStart" href="#MathOptInterface.NLPBlockDualStart"><code>MathOptInterface.NLPBlockDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NLPBlockDualStart()</code></pre><p>An initial assignment of the Lagrange multipliers on the constraints from the <code>NLPBlock</code> that the solver may use to warm-start the solve.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L38-L43">source</a></section><h3><a class="nav-anchor" id="NLP-evaluator-methods-1" href="#NLP-evaluator-methods-1">NLP evaluator methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractNLPEvaluator" href="#MathOptInterface.AbstractNLPEvaluator"><code>MathOptInterface.AbstractNLPEvaluator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractNLPEvaluator</code></pre><p>Abstract supertype for the callback object used in <code>NLPBlock</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.initialize" href="#MathOptInterface.initialize"><code>MathOptInterface.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})</code></pre><p>Must be called before any other methods. The vector <code>requested_features</code> lists features requested by the solver. These may include <code>:Grad</code> for gradients of <span>$f$</span>, <code>:Jac</code> for explicit Jacobians of <span>$g$</span>, <code>:JacVec</code> for Jacobian-vector products, <code>:HessVec</code> for Hessian-vector and Hessian-of-Lagrangian-vector products, <code>:Hess</code> for explicit Hessians and Hessian-of-Lagrangians, and <code>:ExprGraph</code> for expression graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L81-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.features_available" href="#MathOptInterface.features_available"><code>MathOptInterface.features_available</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">features_available(d::AbstractNLPEvaluator)</code></pre><p>Returns the subset of features available for this problem instance, as a list of symbols in the same format as in <code>initialize</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L93-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_objective" href="#MathOptInterface.eval_objective"><code>MathOptInterface.eval_objective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_objective(d::AbstractNLPEvaluator, x)</code></pre><p>Evaluate the objective <span>$f(x)$</span>, returning a scalar value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L101-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_constraint" href="#MathOptInterface.eval_constraint"><code>MathOptInterface.eval_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_constraint(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate the constraint function <span>$g(x)$</span>, storing the result in the vector <code>g</code> which must be of the appropriate size.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L108-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_objective_gradient" href="#MathOptInterface.eval_objective_gradient"><code>MathOptInterface.eval_objective_gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_objective_gradient(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate <span>$\nabla f(x)$</span> as a dense vector, storing the result in the vector <code>g</code> which must be of the appropriate size.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L116-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.jacobian_structure" href="#MathOptInterface.jacobian_structure"><code>MathOptInterface.jacobian_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}</code></pre><p>Returns the sparsity structure of the Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array}\right]$</span> where <span>$g_i$</span> is the <span>$i\text{th}$</span> component of <span>$g$</span>. The sparsity structure is assumed to be independent of the point <span>$x$</span>. Returns a vector of tuples, <code>(row, column)</code>, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L124-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.hessian_lagrangian_structure" href="#MathOptInterface.hessian_lagrangian_structure"><code>MathOptInterface.hessian_lagrangian_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hessian_lagrangian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}</code></pre><p>Returns the sparsity structure of the Hessian-of-the-Lagrangian matrix <span>$\nabla^2 f + \sum_{i=1}^m \nabla^2 g_i$</span> as a vector of tuples, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements <code>(i,j)</code> and <code>(j,i)</code>, if both present, should be treated as duplicates.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L137-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian" href="#MathOptInterface.eval_constraint_jacobian"><code>MathOptInterface.eval_constraint_jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_constraint_jacobian(d::AbstractNLPEvaluator, J, x)</code></pre><p>Evaluates the sparse Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array}\right]$</span>. The result is stored in the vector <code>J</code> in the same order as the indices returned by <code>jacobian_structure</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L150-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian_product" href="#MathOptInterface.eval_constraint_jacobian_product"><code>MathOptInterface.eval_constraint_jacobian_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_constraint_jacobian_product(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-vector product <span>$J_g(x)w$</span>, storing the result in the vector <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L160-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian_transpose_product" href="#MathOptInterface.eval_constraint_jacobian_transpose_product"><code>MathOptInterface.eval_constraint_jacobian_transpose_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_constraint_jacobian_transpose_product(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-transpose-vector product <span>$J_g(x)^Tw$</span>, storing the result in the vector <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L167-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_hessian_lagrangian" href="#MathOptInterface.eval_hessian_lagrangian"><code>MathOptInterface.eval_hessian_lagrangian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_hessian_lagrangian(d::AbstractNLPEvaluator, H, x, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>, computes the sparse Hessian-of-the-Lagrangian matrix <span>$\sigma\nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)$</span>, storing the result in the vector <code>H</code> in the same order as the indices returned by <code>hessian_lagrangian_structure</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L185-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.eval_hessian_lagrangian_product" href="#MathOptInterface.eval_hessian_lagrangian_product"><code>MathOptInterface.eval_hessian_lagrangian_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_hessian_lagrangian_prod(d::AbstractNLPEvaluator, h, x, v, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>, computes the Hessian-of-the-Lagrangian-vector product <span>$\left(\sigma\nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)\right)v$</span>, storing the result in the vector <code>h</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L175-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.objective_expr" href="#MathOptInterface.objective_expr"><code>MathOptInterface.objective_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">objective_expr(d::AbstractNLPEvaluator)</code></pre><p>Returns an expression graph for the objective function as a standard Julia <code>Expr</code> object. All sums and products are flattened out as simple <code>Expr(:+,...)</code> and <code>Expr(:*,...)</code> objects. The symbol <code>x</code> is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression <span>$x_1+\sin(x_2/\exp(x_3))$</span> would be represented as the Julia object <code>:(x[1] + sin(x[2]/exp(x[3])))</code>. See the <a href="https://docs.julialang.org/en/release-0.6/manual/metaprogramming/">Julia manual</a> for more information on the structure of <code>Expr</code> objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like <code>^</code>, <code>exp</code>, <code>log</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, etc., but modeling interfaces may choose to extend these basic functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L196-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.constraint_expr" href="#MathOptInterface.constraint_expr"><code>MathOptInterface.constraint_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">constraint_expr(d::AbstractNLPEvaluator, i)</code></pre><p>Returns an expression graph for the <span>$i\text{th}$</span> constraint in the same format as described above, with an additional comparison operator indicating the sense of and bounds on the constraint. The right-hand side of the comparison must be a constant; that is, <code>:(x[1]^3 &lt;= 1)</code> is allowed, while <code>:(1 &lt;= x[1]^3)</code> is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, <code>:(-1 &lt;= cos(x[1]) + sin(x[2]) &lt;= 1)</code> is valid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/nlp.jl#L214-L224">source</a></section><h2><a class="nav-anchor" id="Errors-1" href="#Errors-1">Errors</a></h2><p>When an MOI call fails on a model, precise errors should be thrown when possible instead of simply calling <code>error</code> with a message. The docstrings for the respective methods describe the errors that the implementation should thrown in certain situations. This error-reporting system allows code to distinguish between internal errors (that should be shown to the user) and unsupported operations which may have automatic workarounds.</p><p>When an invalid index is used in an MOI call, an <a href="#MathOptInterface.InvalidIndex"><code>InvalidIndex</code></a> should be thrown:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.InvalidIndex" href="#MathOptInterface.InvalidIndex"><code>MathOptInterface.InvalidIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct InvalidIndex{IndexType&lt;:Index} &lt;: Exception
    index::IndexType
end</code></pre><p>An error indicating that the index <code>index</code> is invalid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L37-L43">source</a></section><p>The rest of the errors defined in MOI fall in two categories represented by the following two abstract types:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.UnsupportedError" href="#MathOptInterface.UnsupportedError"><code>MathOptInterface.UnsupportedError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnsupportedError &lt;: Exception</code></pre><p>Abstract type for error thrown when an element is not supported by the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/error.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NotAllowedError" href="#MathOptInterface.NotAllowedError"><code>MathOptInterface.NotAllowedError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NotAllowedError &lt;: Exception</code></pre><p>Abstract type for error thrown when an operation is supported but cannot be applied in the current state of the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/error.jl#L26-L31">source</a></section><p>The different <a href="#MathOptInterface.UnsupportedError"><code>UnsupportedError</code></a> and <a href="#MathOptInterface.NotAllowedError"><code>NotAllowedError</code></a> are the following errors:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.UnsupportedAttribute" href="#MathOptInterface.UnsupportedAttribute"><code>MathOptInterface.UnsupportedAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct UnsupportedAttribute{AttrType} &lt;: UnsupportedError
    attr::AttrType
    message::String
end</code></pre><p>An error indicating that the attribute <code>attr</code> is not supported by the model, i.e. that <a href="#MathOptInterface.supports"><code>supports</code></a> returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L45-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SetAttributeNotAllowed" href="#MathOptInterface.SetAttributeNotAllowed"><code>MathOptInterface.SetAttributeNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct SetAttributeNotAllowed{AttrType} &lt;: NotAllowedError
    attr::AttrType
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that the attribute <code>attr</code> is supported (see <a href="#MathOptInterface.supports"><code>supports</code></a>) but cannot be set for some reason (see the error string).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/attributes.jl#L61-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AddVariableNotAllowed" href="#MathOptInterface.AddVariableNotAllowed"><code>MathOptInterface.AddVariableNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct AddVariableNotAllowed &lt;: NotAllowedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that variables cannot be added to the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/variables.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.UnsupportedConstraint" href="#MathOptInterface.UnsupportedConstraint"><code>MathOptInterface.UnsupportedConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct UnsupportedConstraint{F&lt;:AbstractFunction, S&lt;:AbstractSet} &lt;: UnsupportedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that constraints of type <code>F</code>-in-<code>S</code> are not supported by the model, i.e. that <a href="#MathOptInterface.supports_constraint"><code>supports_constraint</code></a> returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L12-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AddConstraintNotAllowed" href="#MathOptInterface.AddConstraintNotAllowed"><code>MathOptInterface.AddConstraintNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct AddConstraintNotAllowed{F&lt;:AbstractFunction, S&lt;:AbstractSet} &lt;: NotAllowedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that constraints of type <code>F</code>-in-<code>S</code> are supported (see <a href="#MathOptInterface.supports_constraint"><code>supports_constraint</code></a>) but cannot be added.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/constraints.jl#L27-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ModifyConstraintNotAllowed" href="#MathOptInterface.ModifyConstraintNotAllowed"><code>MathOptInterface.ModifyConstraintNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ModifyConstraintNotAllowed{F&lt;:AbstractFunction, S&lt;:AbstractSet,
                                         C&lt;:AbstractFunctionModification} &lt;: NotAllowedError
    constraint_index::ConstraintIndex{F, S}
    change::C
    message::String
end</code></pre><p>An error indicating that the constraint modification <code>change</code> cannot be applied to the constraint of index <code>ci</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/modifications.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ModifyObjectiveNotAllowed" href="#MathOptInterface.ModifyObjectiveNotAllowed"><code>MathOptInterface.ModifyObjectiveNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ModifyObjectiveNotAllowed{C&lt;:AbstractFunctionModification} &lt;: NotAllowedError
    change::C
    message::String
end</code></pre><p>An error indicating that the objective modification <code>change</code> cannot be applied to the objective.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/modifications.jl#L25-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DeleteNotAllowed" href="#MathOptInterface.DeleteNotAllowed"><code>MathOptInterface.DeleteNotAllowed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DeleteNotAllowed{IndexType &lt;: Index} &lt;: NotAllowedError
    index::IndexType
    message::String
end</code></pre><p>An error indicating that the index <code>index</code> cannot be deleted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/indextypes.jl#L59-L66">source</a></section><h2><a class="nav-anchor" id="Bridges-1" href="#Bridges-1">Bridges</a></h2><p>Bridges can be used for automatic reformulation of a certain constraint type into equivalent constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridge" href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractBridge</code></pre><p>A bridge represents a bridged constraint in an <code>AbstractBridgeOptimizer</code>. It contains the indices of the constraints that it has created in the model. These can be obtained using <code>MOI.NumberOfConstraints</code> and <code>MOI.ListOfConstraintIndices</code> and using the bridge in place of a <code>ModelLike</code>. Attributes of the bridged model such as <code>MOI.ConstraintDual</code> and <code>MOI.ConstraintPrimal</code>, can be obtained using the bridge in place of the constraint index. These calls are used by the <code>AbstractBridgeOptimizer</code> to communicate with the bridge so they should be implemented by the bridge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/bridge.jl#L3-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridgeOptimizer" href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractBridgeOptimizer</code></pre><p>A bridge optimizer applies given constraint bridges to a given optimizer thus extending the types of supported constraints. The attributes of the inner optimizer are automatically transformed to make the bridges transparent, e.g. the variables and constraints created by the bridges are hidden.</p><p>By convention, the inner optimizer should be stored in a <code>model</code> field and the dictionary mapping constraint indices to bridges should be stored in a <code>bridges</code> field. If a bridge optimizer deviates from these conventions, it should implement the functions <code>MOI.optimize!</code> and <code>bridge</code> respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/bridgeoptimizer.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SingleBridgeOptimizer{BT&lt;:AbstractBridge, MT&lt;:MOI.ModelLike, OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any constraint supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a> which only bridges the constraints that are unsupported by the internal model, even if they are supported by one of its bridges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/singlebridgeoptimizer.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.LazyBridgeOptimizer" href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazyBridgeOptimizer{OT&lt;:MOI.ModelLike, MT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>LazyBridgeOptimizer</code> combines several bridges, which are added using the <a href="#MathOptInterface.Bridges.add_bridge"><code>add_bridge</code></a> function. Whenever a constraint is added, it only attempts to bridge it if it is not supported by the internal model (hence its name <code>Lazy</code>). When bridging a constraint, it selects the minimal number of bridges needed. For instance, a constraint <code>F</code>-in-<code>S</code> can be bridged into a constraint <code>F1</code>-in-<code>S1</code> (supported by the internal model) using bridge 1 or bridged into a constraint <code>F2</code>-in-<code>S2</code> (unsupported by the internal model) using bridge 2 which can then be bridged into a constraint <code>F3</code>-in-<code>S3</code> (supported by the internal model) using bridge 3, it will choose bridge 1 as it allows to bridge <code>F</code>-in-<code>S</code> using only one bridge instead of two if it uses bridge 2 and 3.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/lazybridgeoptimizer.jl#L2-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.add_bridge" href="#MathOptInterface.Bridges.add_bridge"><code>MathOptInterface.Bridges.add_bridge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Enable the use of the bridges of type <code>BT</code> by <code>b</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/lazybridgeoptimizer.jl#L86-L90">source</a></section><p>Below is the list of bridges implemented in this package.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.SplitIntervalBridge" href="#MathOptInterface.Bridges.SplitIntervalBridge"><code>MathOptInterface.Bridges.SplitIntervalBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SplitIntervalBridge{T}</code></pre><p>The <code>SplitIntervalBridge</code> splits a constraint <span>$l ≤ ⟨a, x⟩ + α ≤ u$</span> into the constraints <span>$⟨a, x⟩ + α ≥ l$</span> and <span>$⟨a, x⟩ + α ≤ u$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/intervalbridge.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.RSOCBridge" href="#MathOptInterface.Bridges.RSOCBridge"><code>MathOptInterface.Bridges.RSOCBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RSOCBridge{T}</code></pre><p>The <code>RotatedSecondOrderCone</code> is <code>SecondOrderCone</code> representable; see [1, p. 104]. Indeed, we have <span>$2tu = (t/√2 + u/√2)^2 - (t/√2 - u/√2)^2$</span> hence</p><div>\[2tu \ge || x ||_2^2\]</div><p>is equivalent to</p><div>\[(t/√2 + u/√2)^2 \ge || x ||_2^2 + (t/√2 - u/√2)^2.\]</div><p>We can therefore use the transformation <span>$(t, u, x) \mapsto (t/√2+u/√2, t/√2-u/√2, x)$</span>. Note that the linear transformation is a symmetric involution (i.e. it is its own transpose and its own inverse). That means in particular that the norm is of constraint primal and duals are preserved by the tranformation.</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/rsocbridge.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.GeoMeanBridge" href="#MathOptInterface.Bridges.GeoMeanBridge"><code>MathOptInterface.Bridges.GeoMeanBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GeoMeanBridge{T}</code></pre><p>The <code>GeometricMeanCone</code> is <code>SecondOrderCone</code> representable; see [1, p. 105]. The reformulation is best described in an example. Consider the cone of dimension 4</p><div>\[t \le \sqrt[3]{x_1 x_2 x_3}\]</div><p>This can be rewritten as <span>$\exists x_{21} \ge 0$</span> such that</p><div>\[\begin{align*}
  t &amp; \le x_{21},\\
  x_{21}^4 &amp; \le x_1 x_2 x_3 x_{21}.
\end{align*}\]</div><p>Note that we need to create <span>$x_{21}$</span> and not use <span>$t^4$</span> directly as <span>$t$</span> is allowed to be negative. Now, this is equivalent to</p><div>\[\begin{align*}
  t &amp; \le x_{21}/\sqrt{4},\\
  x_{21}^2 &amp; \le 2x_{11} x_{12},\\
  x_{11}^2 &amp; \le 2x_1 x_2, &amp; x_{21}^2 &amp; \le 2x_3(x_{21}/\sqrt{4}).
\end{align*}\]</div><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/geomeanbridge.jl#L13-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.SquarePSDBridge" href="#MathOptInterface.Bridges.SquarePSDBridge"><code>MathOptInterface.Bridges.SquarePSDBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SquarePSDBridge{T}</code></pre><p>The <code>SquarePSDBridge</code> reformulates the constraint of a square matrix to be PSD and symmetric, i.e. belongs to the <a href="#MathOptInterface.PositiveSemidefiniteConeSquare"><code>MOI.PositiveSemidefiniteConeSquare</code></a>, to a list of equality constraints for pair or off-diagonal entries with different expressions and a PSD constraint the upper triangular part of the matrix.</p><p>For instance, the constraint for the matrix</p><div>\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\
  1 +  x &amp; 2 + x &amp; 3 -  x\
  2 - 3x &amp; 2 + x &amp;     2x
\end{pmatrix}\]</div><p>to be PSD can be broken down to the constraint of the symmetric matrix</p><div>\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\
  \cdot &amp; 2 + x &amp; 3 -  x\
  \cdot &amp; \cdot &amp;    2x
\end{pmatrix}\]</div><p>and the equality constraint between the off-diagonal entries (2, 3) and (3, 2) <span>$2x == 1$</span>. Note that now symmetrization constraint need to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) since the expressions are the same.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/squarepsdbridge.jl#L37-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.RootDetBridge" href="#MathOptInterface.Bridges.RootDetBridge"><code>MathOptInterface.Bridges.RootDetBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RootDetBridge{T}</code></pre><p>The <code>RootDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and an <code>GeometricMeanCone</code> constraints; see [1, p. 149]. Indeed, <span>$t \le \det(X)^(1/n)$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><div>\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le (Δ_{11} Δ_{22} \cdots Δ_{nn})^{1/n}
\end{align*}\]</div><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/detbridge.jl#L142-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.LogDetBridge" href="#MathOptInterface.Bridges.LogDetBridge"><code>MathOptInterface.Bridges.LogDetBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LogDetBridge{T}</code></pre><p>The <code>LogDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and <code>ExponentialCone</code> constraints. Indeed, <span>$\log\det(X) = \log(\delta_1) + \cdots + \log(\delta_n)$</span> where <span>$\delta_1$</span>, ..., <span>$\delta_n$</span> are the eigenvalues of <span>$X$</span>. Adapting, the method from [1, p. 149], we see that <span>$t \le \log(\det(X))$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><div>\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le \log(Δ_{11}) + \log(Δ_{22}) + \cdots + \log(Δ_{nn})
\end{align*}\]</div><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001. ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/detbridge.jl#L50-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.SOCtoPSDBridge" href="#MathOptInterface.Bridges.SOCtoPSDBridge"><code>MathOptInterface.Bridges.SOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>SOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le t$</span> into the semidefinite cone constraints</p><div>\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; tI
\end{pmatrix} \succeq 0\]</div><p>Indeed by the Schur Complement, it is positive definite iff</p><div>\[\begin{align*}
  tI &amp; \succ 0\\
  t - x^\top (tI)^{-1} x &amp; \succ 0
\end{align*}\]</div><p>which is equivalent to</p><div>\[\begin{align*}
  t &amp; &gt; 0\\
  t^2 &amp; &gt; x^\top x
\end{align*}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/soctopsdbridge.jl#L31-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Bridges.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>RSOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le 2tu$</span> with <span>$u \ge 0$</span> into the semidefinite cone constraints</p><div>\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; 2uI
\end{pmatrix} \succeq 0\]</div><p>Indeed by the Schur Complement, it is positive definite iff</p><div>\[\begin{align*}
  uI &amp; \succ 0\\
  t - x^\top (2uI)^{-1} x &amp; \succ 0
\end{align*}\]</div><p>which is equivalent to</p><div>\[\begin{align*}
  u &amp; &gt; 0\\
  2tu &amp; &gt; x^\top x
\end{align*}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Bridges/soctopsdbridge.jl#L86-L108">source</a></section><p>For each bridge defined in this package, a corresponding bridge optimizer is available with the same name without the &quot;Bridge&quot; suffix, e.g., <code>SplitInterval</code> is an <code>SingleBridgeOptimizer</code> for the <code>SplitIntervalBridge</code>.</p><h2><a class="nav-anchor" id="Copy-utilities-1" href="#Copy-utilities-1">Copy utilities</a></h2><p>The following utilities can be used to implement <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. See <a href="../apimanual/#Implementing-copy-1">Implementing copy</a> for more details.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.automatic_copy_to" href="#MathOptInterface.Utilities.automatic_copy_to"><code>MathOptInterface.Utilities.automatic_copy_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">automatic_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike;
                  copy_names::Bool=true)</code></pre><p>Use <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a> and <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> to automatically choose between <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> or <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> to apply the copy operation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L3-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.default_copy_to" href="#MathOptInterface.Utilities.default_copy_to"><code>MathOptInterface.Utilities.default_copy_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike, copy_names::Bool)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> by adding the variables and then the constraints and attributes incrementally. The function <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>supports_default_copy_to</code></a> can be used to check whether <code>dest</code> supports the copying a model incrementally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L159-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.supports_default_copy_to" href="#MathOptInterface.Utilities.supports_default_copy_to"><code>MathOptInterface.Utilities.supports_default_copy_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">supports_default_copy_to(model::ModelLike, copy_names::Bool)</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>model</code> supports <a href="#MathOptInterface.Utilities.default_copy_to"><code>default_copy_to(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p><p>This function can be used to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead. This is used by JuMP to determine whether to add a cache or not in two situations:</p><ol><li>A first cache can be used to store the model as entered by the user as well as the names of variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>true</code>.</li><li>If bridges are used, then a second cache can be used to store the bridged model with unnamed variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>false</code>.</li></ol><p><strong>Examples</strong></p><p>If <a href="#MathOptInterface.set"><code>MathOptInterface.set</code></a>, <a href="#MathOptInterface.add_variable"><code>MathOptInterface.add_variable</code></a> and <a href="#MathOptInterface.add_constraint"><code>MathOptInterface.add_constraint</code></a> are implemented for a model of type <code>MyModel</code> and names are supported, then <a href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> can be implemented as</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::MyModel, copy_names::Bool) = true
function MOI.copy_to(dest::MyModel, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src, kws...)
end</code></pre><p>The <a href="#MathOptInterface.Utilities.automatic_copy_to"><code>Utilities.automatic_copy_to</code></a> function automatically redirects to <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a>.</p><p>If names are not supported, simply change the first line by</p><pre><code class="language-julia">MOI.supports_default_copy_to(model::MyModel, copy_names::Bool) = !copy_names</code></pre><p>The <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> function automatically throws an helpful error in case <code>copy_to</code> is called with <code>copy_names</code> equal to <code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L24-L63">source</a></section><h3><a class="nav-anchor" id="Allocate-Load-API-1" href="#Allocate-Load-API-1">Allocate-Load API</a></h3><p>The Allocate-Load API allows solvers that do not support loading the problem incrementally to implement <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> in a way that still allows transformations to be applied in the copy between the cache and the model if the transformations are implemented as MOI layers implementing the Allocate-Load API, see <a href="../apimanual/#Implementing-copy-1">Implementing copy</a> for more details.</p><p>Loading a model using the Allocate-Load interface consists of two passes through the model data:</p><ol><li>the allocate pass where the model typically records the necessary information about the constraints and attributes such as their number and size. This information may be used by the solver to allocate datastructures of appropriate size.</li><li>the load pass where the model typically loads the constraint and attribute data to the model.</li></ol><p>The description above only gives a suggestion of what to achieve in each pass. In fact the exact same constraint and attribute data is provided to each pass, so an implementation of the Allocate-Load API is free to do whatever is more convenient in each pass.</p><p>The main difference between each pass, apart from the fact that one is executed before the other during a copy, is that the allocate pass needs to create and return new variable and constraint indices, while during the load pass the appropriate constraint indices are provided.</p><p>The Allocate-Load API is <strong>not</strong> meant to be used outside a copy operation, that is, the interface is not meant to be used to create new constraints with <a href="#MathOptInterface.Utilities.allocate_constraint"><code>Utilities.allocate_constraint</code></a> followed by <a href="#MathOptInterface.Utilities.load_constraint"><code>Utilities.load_constraint</code></a> after a solve. This means that the order in which the different functions of the API are called is fixed by <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> and models implementing the API can rely on the fact that functions will be called in this order. That is, it can be assumed that the different functions will the called in the following order:</p><ol><li><a href="#MathOptInterface.Utilities.allocate_variables"><code>Utilities.allocate_variables</code></a></li><li><a href="#MathOptInterface.Utilities.allocate"><code>Utilities.allocate</code></a> and <a href="#MathOptInterface.Utilities.allocate_constraint"><code>Utilities.allocate_constraint</code></a></li><li><a href="#MathOptInterface.Utilities.load_variables"><code>Utilities.load_variables</code></a></li><li><a href="#MathOptInterface.Utilities.load"><code>Utilities.load</code></a> and <a href="#MathOptInterface.Utilities.load_constraint"><code>Utilities.load_constraint</code></a></li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_load" href="#MathOptInterface.Utilities.allocate_load"><code>MathOptInterface.Utilities.allocate_load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allocate_load(dest::MOI.ModelLike, src::MOI.ModelLike)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> using the Allocate-Load API. The function <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>supports_allocate_load</code></a> can be used to check whether <code>dest</code> supports the Allocate-Load API.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L330-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.supports_allocate_load" href="#MathOptInterface.Utilities.supports_allocate_load"><code>MathOptInterface.Utilities.supports_allocate_load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">supports_allocate_load(model::MOI.ModelLike, copy_names::Bool)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <a href="#MathOptInterface.Utilities.allocate_load"><code>allocate_load(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L217-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_variables" href="#MathOptInterface.Utilities.allocate_variables"><code>MathOptInterface.Utilities.allocate_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allocate_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Creates <code>nvars</code> variables and returns a vector of <code>nvars</code> variable indices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L226-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.allocate" href="#MathOptInterface.Utilities.allocate"><code>MathOptInterface.Utilities.allocate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allocate(model::ModelLike, attr::ModelLikeAttribute, value)
allocate(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
allocate(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Informs <code>model</code> that <code>load</code> will be called with the same arguments after <code>load_variables</code> is called.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L236-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constraint" href="#MathOptInterface.Utilities.allocate_constraint"><code>MathOptInterface.Utilities.allocate_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allocate_constraint(model::MOI.ModelLike, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Returns the index for the constraint to be used in <code>load_constraint</code> that will be called after <code>load_variables</code> is called.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L254-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.load_variables" href="#MathOptInterface.Utilities.load_variables"><code>MathOptInterface.Utilities.load_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Prepares the <code>model</code> for <code>loadobjective!</code> and <code>load_constraint</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L265-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.load" href="#MathOptInterface.Utilities.load"><code>MathOptInterface.Utilities.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load(model::ModelLike, attr::ModelLikeAttribute, value)
load(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
load(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>This has the same effect that <code>set</code> with the same arguments except that <code>allocate</code> should be called first before <code>load_variables</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L272-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Utilities.load_constraint" href="#MathOptInterface.Utilities.load_constraint"><code>MathOptInterface.Utilities.load_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_constraint(model::MOI.ModelLike, ci::MOI.ConstraintIndex, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Sets the constraint function and set for the constraint of index <code>ci</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/c50524522d3551ab7819124b6a2e220ccd4091d5/src/Utilities/copy.jl#L290-L294">source</a></section><footer><hr/><a class="previous" href="../apimanual/"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
